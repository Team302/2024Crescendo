//====================================================================================================================================================
// Copyright 2024 Lake Orion Robotics FIRST Team 302
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
// OR OTHER DEALINGS IN THE SOFTWARE.
//====================================================================================================================================================
// This file was automatically generated by the Team 302 code generator version 1.3.0.7
// Generated on Tuesday, February 20, 2024 9:06:50 PM

// C++ Includes

// FRC Includes

// Team 302 includes
#include "PeriodicLooper.h"
#include "mechanisms/noteManager/decoratormods/noteManager.h"

#include "hw/DragonSparkMax.h"
#include "hw/DragonSparkFlex.h"
#include "hw/DragonTalonFX.h"
#include "hw/DragonDigitalInput.h"
#include "mechanisms/noteManager/decoratormods/OffState.h"
#include "mechanisms/noteManager/decoratormods/ReadyState.h"
#include "mechanisms/noteManager/decoratormods/feederIntakeState.h"
#include "mechanisms/noteManager/decoratormods/ExpelState.h"
#include "mechanisms/noteManager/decoratormods/placerIntakeState.h"
#include "mechanisms/noteManager/decoratormods/launcherToPlacerState.h"
#include "mechanisms/noteManager/decoratormods/holdFeederState.h"
#include "mechanisms/noteManager/decoratormods/readyAutoLaunchState.h"
#include "mechanisms/noteManager/decoratormods/readyManualLaunchState.h"
#include "mechanisms/noteManager/decoratormods/PassState.h"
#include "mechanisms/noteManager/decoratormods/autoLaunchState.h"
#include "mechanisms/noteManager/decoratormods/manualLaunchState.h"
#include "mechanisms/noteManager/decoratormods/readyOdometryLaunchState.h"
#include "mechanisms/noteManager/decoratormods/autoLaunchOdometryState.h"
#include "mechanisms/noteManager/decoratormods/preparePlaceAmpState.h"
#include "mechanisms/noteManager/decoratormods/preparePlaceTrapState.h"
#include "mechanisms/noteManager/decoratormods/placeAmpState.h"
#include "mechanisms/noteManager/decoratormods/placeTrapState.h"
#include "mechanisms/noteManager/decoratormods/placerToLauncherState.h"
#include "mechanisms/noteManager/decoratormods/backupManualLaunchState.h"
#include "mechanisms/noteManager/decoratormods/backupManualPlaceState.h"
#include "mechanisms/noteManager/decoratormods/holdPlacerState.h"

#include "DragonVision/DragonVision.h"
#include "robotstate/RobotState.h"
#include "utils/logging/Logger.h"
#include "utils/logging/DataTrace.h"

using std::string;
using namespace noteManagerStates;

/// @brief  This method constructs the mechanism using composition with its various actuators and sensors.
/// @param controlFileName The control file with the PID constants and Targets for each state
/// @param networkTableName Location for logging information
/// @param motor  Motor in the mechanims - code generator should probably use the usage for the variable name
/// @param otherMotor Same as previous
/// @param solenoid Solenoid in the mechanism - code generator should probably use the usage for the variable name
/// Additional actuators and sensors are also in this list.
noteManager::noteManager(noteManagerGen *base, RobotConfigMgr::RobotIdentifier activeRobotId) : noteManagerGen(activeRobotId), IRobotStateChangeSubscriber(),
																								m_noteManager(base)
{
	PeriodicLooper::GetInstance()->RegisterAll(this);

	m_scoringMode = RobotStateChanges::ScoringMode::Launcher;
	m_climbMode = RobotStateChanges::ClimbMode::ClimbModeOff;
	m_gamePeriod = RobotStateChanges::GamePeriod::Disabled;

	RobotState *RobotStates = RobotState::GetInstance();

	RobotStates->RegisterForStateChanges(this, RobotStateChanges::StateChange::DesiredScoringMode);
	RobotStates->RegisterForStateChanges(this, RobotStateChanges::StateChange::ClimbModeStatus);
	RobotStates->RegisterForStateChanges(this, RobotStateChanges::StateChange::GameState);
}

void noteManager::RunCommonTasks()
{
	// This function is called once per loop before the current state Run()
	Cyclic();
	ResetLauncherAngle();
	ResetElevator();

#ifdef INCLUDE_DATA_TRACE
	double wheelSetTop = getlauncherTop()->GetRPS();
	double wheelSetBottom = getlauncherBottom()->GetRPS();
	double angle = getlauncherAngle()->GetCounts();
	double elevator = getElevator()->GetCounts();
	DataTrace::GetInstance()->sendElevatorData(elevator);
	DataTrace::GetInstance()->sendLauncherData(wheelSetTop, wheelSetBottom, angle);
#endif
}

void noteManager::ResetElevator()
{
	if (getElevator()->IsReverseLimitSwitchClosed())
		getElevator()->SetSelectedSensorPosition(0);
}

void noteManager::ResetLauncherAngle()
{
	if (getlauncherAngle()->IsReverseLimitSwitchClosed())
		getlauncherAngle()->SetSelectedSensorPosition(0);
}

void noteManager::SetCurrentState(int state, bool run)
{
	noteManagerGen::SetCurrentState(state, run);
	Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, string("State Transition"), string("Note Manager Current State"), GetCurrentStatePtr()->GetStateName());
}

units::length::meter_t noteManager::GetVisionDistance()
{
	units::length::meter_t distance{units::length::meter_t(0)};
	std::optional<VisionData> optionalVisionData = DragonVision::GetDragonVision()->GetVisionData(DragonVision::VISION_ELEMENT::SPEAKER);
	if (optionalVisionData)
	{
		frc::Translation3d translate{optionalVisionData.value().translationToTarget};
		double x{translate.X().to<double>()};
		double y{translate.Y().to<double>()};
		distance = units::length::meter_t(std::hypot(x, y));
	}
	return distance;
}

bool noteManager::HasVisionTarget()
{
	std::optional<VisionData> optionalVisionData = DragonVision::GetDragonVision()->GetVisionData(DragonVision::VISION_ELEMENT::SPEAKER);
	if (optionalVisionData)
	{
		return true;
	}
	return false;
}

void noteManager::Update(RobotStateChanges::StateChange change, int value)
{
	if (change == RobotStateChanges::DesiredScoringMode)
		m_scoringMode = static_cast<RobotStateChanges::ScoringMode>(value);
	else if (change == RobotStateChanges::ClimbModeStatus)
		m_climbMode = static_cast<RobotStateChanges::ClimbMode>(value);
	else if (change == RobotStateChanges::GameState)
		m_gamePeriod = static_cast<RobotStateChanges::GamePeriod>(value);
}

double noteManager::GetRequiredLaunchAngle()
{
	double distanceFromTarget = 1.1;
	double launchAngle = -51.0;

	if (HasVisionTarget())
	{
		distanceFromTarget = GetVisionDistance().to<double>();
		if (distanceFromTarget < 1.5)
		{
			launchAngle = -24;
		}
		else
		{
			launchAngle = 6.72 + (-27.1 * distanceFromTarget) + (2.85 * distanceFromTarget * distanceFromTarget);
		}
	}
	if (launchAngle > -10.0)
	{
		launchAngle = -10.0;
	}
	return launchAngle;
}

bool noteManager::autoLaunchReady()
{
	std::optional<VisionData> optionalVisionData = DragonVision::GetDragonVision()->GetVisionData(DragonVision::VISION_ELEMENT::SPEAKER);
	if (optionalVisionData.has_value())
	{
		VisionData visionData = optionalVisionData.value();
		Logger::GetLogger()->LogData(LOGGER_LEVEL::PRINT, string("Launcher"), string("Distance Y"), visionData.transformToTarget.Y().to<double>());
		if (visionData.transformToTarget.Y().to<double>() <= 0.5 && GetVisionDistance().to<double>() <= 3.5)
		{
			return true;
		}
	}
	return false;
}

void noteManager::CreateAndRegisterStates()
{
	OffState *OffStateInst = new OffState(string("Off"), 0, new noteManagerAllStatesStateGen(m_activeRobotId, string("Off"), 0, this), this);
	AddToStateVector(OffStateInst);

	ReadyState *ReadyStateInst = new ReadyState(string("Ready"), 1, new noteManagerAllStatesStateGen(m_activeRobotId, string("Ready"), 1, this), this);
	AddToStateVector(ReadyStateInst);

	feederIntakeState *feederIntakeStateInst = new feederIntakeState(string("feederIntake"), 2, new noteManagerAllStatesStateGen(m_activeRobotId, string("feederIntake"), 2, this), this);
	AddToStateVector(feederIntakeStateInst);

	ExpelState *ExpelStateInst = new ExpelState(string("Expel"), 3, new noteManagerAllStatesStateGen(m_activeRobotId, string("Expel"), 3, this), this);
	AddToStateVector(ExpelStateInst);

	placerIntakeState *placerIntakeStateInst = new placerIntakeState(string("placerIntake"), 4, new noteManagerAllStatesStateGen(m_activeRobotId, string("placerIntake"), 4, this), this);
	AddToStateVector(placerIntakeStateInst);

	launcherToPlacerState *launcherToPlacerStateInst = new launcherToPlacerState(string("launcherToPlacer"), 5, new noteManagerAllStatesStateGen(m_activeRobotId, string("launcherToPlacer"), 5, this), this);
	AddToStateVector(launcherToPlacerStateInst);

	holdFeederState *holdFeederStateInst = new holdFeederState(string("holdFeeder"), 6, new noteManagerAllStatesStateGen(m_activeRobotId, string("holdFeeder"), 6, this), this);
	AddToStateVector(holdFeederStateInst);

	readyAutoLaunchState *readyAutoLaunchStateInst = new readyAutoLaunchState(string("readyAutoLaunch"), 7, new noteManagerAllStatesStateGen(m_activeRobotId, string("readyAutoLaunch"), 7, this), this);
	AddToStateVector(readyAutoLaunchStateInst);

	readyManualLaunchState *readyManualLaunchStateInst = new readyManualLaunchState(string("readyManualLaunch"), 8, new noteManagerAllStatesStateGen(m_activeRobotId, string("readyManualLaunch"), 8, this), this);
	AddToStateVector(readyManualLaunchStateInst);

	PassState *PassStateInst = new PassState(string("Pass"), 9, new noteManagerAllStatesStateGen(m_activeRobotId, string("Pass"), 9, this), this);
	AddToStateVector(PassStateInst);

	autoLaunchState *autoLaunchStateInst = new autoLaunchState(string("autoLaunch"), 10, new noteManagerAllStatesStateGen(m_activeRobotId, string("autoLaunch"), 10, this), this);
	AddToStateVector(autoLaunchStateInst);

	manualLaunchState *manualLaunchStateInst = new manualLaunchState(string("manualLaunch"), 11, new noteManagerAllStatesStateGen(m_activeRobotId, string("manualLaunch"), 11, this), this);
	AddToStateVector(manualLaunchStateInst);

	readyOdometryLaunchState *readyOdometryLaunchStateInst = new readyOdometryLaunchState(string("readyOdometryLaunch"), 12, new noteManagerAllStatesStateGen(m_activeRobotId, string("readyOdometryLaunch"), 12, this), this);
	AddToStateVector(readyOdometryLaunchStateInst);

	autoLaunchOdometryState *autoLaunchOdometryStateInst = new autoLaunchOdometryState(string("autoLaunchOdometry"), 13, new noteManagerAllStatesStateGen(m_activeRobotId, string("autoLaunchOdometry"), 13, this), this);
	AddToStateVector(autoLaunchOdometryStateInst);

	preparePlaceAmpState *preparePlaceAmpStateInst = new preparePlaceAmpState(string("preparePlaceAmp"), 14, new noteManagerAllStatesStateGen(m_activeRobotId, string("preparePlaceAmp"), 14, this), this);
	AddToStateVector(preparePlaceAmpStateInst);

	preparePlaceTrapState *preparePlaceTrapStateInst = new preparePlaceTrapState(string("preparePlaceTrap"), 15, new noteManagerAllStatesStateGen(m_activeRobotId, string("preparePlaceTrap"), 15, this), this);
	AddToStateVector(preparePlaceTrapStateInst);

	placeAmpState *placeAmpStateInst = new placeAmpState(string("placeAmp"), 16, new noteManagerAllStatesStateGen(m_activeRobotId, string("placeAmp"), 16, this), this);
	AddToStateVector(placeAmpStateInst);

	placeTrapState *placeTrapStateInst = new placeTrapState(string("placeTrap"), 17, new noteManagerAllStatesStateGen(m_activeRobotId, string("placeTrap"), 17, this), this);
	AddToStateVector(placeTrapStateInst);

	placerToLauncherState *placerToLauncherStateInst = new placerToLauncherState(string("placerToLauncher"), 18, new noteManagerAllStatesStateGen(m_activeRobotId, string("placerToLauncher"), 18, this), this);
	AddToStateVector(placerToLauncherStateInst);

	backupManualLaunchState *backupManualLaunchStateInst = new backupManualLaunchState(string("backupManualLaunch"), 19, new noteManagerAllStatesStateGen(m_activeRobotId, string("backupManualLaunch"), 19, this), this);
	AddToStateVector(backupManualLaunchStateInst);

	backupManualPlaceState *backupManualPlaceStateInst = new backupManualPlaceState(string("backupManualPlace"), 20, new noteManagerAllStatesStateGen(m_activeRobotId, string("backupManualPlace"), 20, this), this);
	AddToStateVector(backupManualPlaceStateInst);

	holdPlacerState *holdPlacerStateInst = new holdPlacerState(string("holdPlacer"), 21, new noteManagerAllStatesStateGen(m_activeRobotId, string("holdPlacer"), 21, this), this);
	AddToStateVector(holdPlacerStateInst);

	OffStateInst->RegisterTransitionState(ReadyStateInst);
	ReadyStateInst->RegisterTransitionState(feederIntakeStateInst);
	ReadyStateInst->RegisterTransitionState(ExpelStateInst);
	ReadyStateInst->RegisterTransitionState(placerIntakeStateInst);
	ReadyStateInst->RegisterTransitionState(backupManualLaunchStateInst);
	ReadyStateInst->RegisterTransitionState(backupManualPlaceStateInst);
	feederIntakeStateInst->RegisterTransitionState(ReadyStateInst);
	feederIntakeStateInst->RegisterTransitionState(holdFeederStateInst);
	feederIntakeStateInst->RegisterTransitionState(ExpelStateInst);
	ExpelStateInst->RegisterTransitionState(ReadyStateInst);
	ExpelStateInst->RegisterTransitionState(feederIntakeStateInst);
	ExpelStateInst->RegisterTransitionState(placerIntakeStateInst);
	placerIntakeStateInst->RegisterTransitionState(ReadyStateInst);
	placerIntakeStateInst->RegisterTransitionState(holdPlacerStateInst);
	placerIntakeStateInst->RegisterTransitionState(ExpelStateInst);
	launcherToPlacerStateInst->RegisterTransitionState(ReadyStateInst);
	launcherToPlacerStateInst->RegisterTransitionState(placerIntakeStateInst);
	holdFeederStateInst->RegisterTransitionState(ReadyStateInst);
	holdFeederStateInst->RegisterTransitionState(readyAutoLaunchStateInst);
	holdFeederStateInst->RegisterTransitionState(readyManualLaunchStateInst);
	holdFeederStateInst->RegisterTransitionState(PassStateInst);
	holdFeederStateInst->RegisterTransitionState(launcherToPlacerStateInst);
	readyAutoLaunchStateInst->RegisterTransitionState(ReadyStateInst);
	readyAutoLaunchStateInst->RegisterTransitionState(holdFeederStateInst);
	readyAutoLaunchStateInst->RegisterTransitionState(autoLaunchStateInst);
	readyManualLaunchStateInst->RegisterTransitionState(ReadyStateInst);
	readyManualLaunchStateInst->RegisterTransitionState(manualLaunchStateInst);
	PassStateInst->RegisterTransitionState(ReadyStateInst);
	autoLaunchStateInst->RegisterTransitionState(ReadyStateInst);
	manualLaunchStateInst->RegisterTransitionState(ReadyStateInst);
	readyOdometryLaunchStateInst->RegisterTransitionState(ReadyStateInst);
	readyOdometryLaunchStateInst->RegisterTransitionState(readyAutoLaunchStateInst);
	readyOdometryLaunchStateInst->RegisterTransitionState(autoLaunchOdometryStateInst);
	autoLaunchOdometryStateInst->RegisterTransitionState(ReadyStateInst);
	preparePlaceAmpStateInst->RegisterTransitionState(ReadyStateInst);
	preparePlaceAmpStateInst->RegisterTransitionState(preparePlaceTrapStateInst);
	preparePlaceAmpStateInst->RegisterTransitionState(placeAmpStateInst);
	preparePlaceTrapStateInst->RegisterTransitionState(ReadyStateInst);
	preparePlaceTrapStateInst->RegisterTransitionState(preparePlaceAmpStateInst);
	preparePlaceTrapStateInst->RegisterTransitionState(placeTrapStateInst);
	placeAmpStateInst->RegisterTransitionState(ReadyStateInst);
	placeTrapStateInst->RegisterTransitionState(ReadyStateInst);
	placerToLauncherStateInst->RegisterTransitionState(ReadyStateInst);
	placerToLauncherStateInst->RegisterTransitionState(feederIntakeStateInst);
	backupManualLaunchStateInst->RegisterTransitionState(ReadyStateInst);
	backupManualLaunchStateInst->RegisterTransitionState(backupManualPlaceStateInst);
	backupManualPlaceStateInst->RegisterTransitionState(ReadyStateInst);
	backupManualPlaceStateInst->RegisterTransitionState(backupManualLaunchStateInst);
	holdPlacerStateInst->RegisterTransitionState(preparePlaceAmpStateInst);
	holdPlacerStateInst->RegisterTransitionState(preparePlaceTrapStateInst);
	holdPlacerStateInst->RegisterTransitionState(placerToLauncherStateInst);
}
