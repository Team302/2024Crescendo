// clang-format off
// clang-format off
//====================================================================================================================================================
// Copyright 2023 Lake Orion Robotics FIRST Team 302
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
// OR OTHER DEALINGS IN THE SOFTWARE.
//====================================================================================================================================================
// This file was automatically generated by the Team 302 code generator version 1.2.1.0
// Generated on Thursday, January 25, 2024 11:02:48 PM

#include <string>

// FRC Includes
#include <networktables/NetworkTableInstance.h>
#include "hw/interfaces/IDragonMotorController.h"

#include "noteManager_gen.h"

#include "hw/DragonSparkMax.h"
#include "hw/DragonSparkMax.h"
#include "hw/DragonSparkMax.h"
#include "hw/DragonTalonFX.h"
#include "hw/DragonSparkFlex.h"
#include "hw/DragonSparkFlex.h"
#include "hw/DragonTalonFX.h"
#include "hw/DragonTalonFX.h"
#include "hw/DragonTalonSRX.h"

#include "hw/DragonDigitalInput.h"
#include "hw/DragonDigitalInput.h"
#include "hw/DragonDigitalInput.h"
#include "hw/DragonDigitalInput.h"
#include "hw/DragonDigitalInput.h"
#include "hw/DragonDigitalInput.h"
#include "hw/DragonDigitalInput.h"

#include "hw/DragonCanCoder.h"

#include "mechanisms/noteManager/decoratormods/noteManager_Off_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_Ready_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_feederIntake_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_Expel_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_placerIntake_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_holdFeederFront_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_holdFeederBack_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_intakeToFeeder_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_launcherToPlacerFront_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_launcherToPlacerBack_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_holdFeeder_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_readyAutoLaunch_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_readyManualLaunch_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_Pass_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_autoLaunch_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_manualLaunch_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_readyOdometryLaunch_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_autoLaunchOdometry_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_holdPlacerFront_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_holdPlacerBack_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_intakeToPlacer_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_preparePlaceAmp_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_preparePlaceTrap_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_placeAmp_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_placeTrap_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_placerToLauncherFront_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_placerToLauncherBack_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_backupManualLaunch_State.h"
#include "mechanisms/noteManager/decoratormods/noteManager_backupManualPlace_State.h"

using ctre::phoenix6::signals::ForwardLimitSourceValue;
using ctre::phoenix6::signals::ForwardLimitTypeValue;
using ctre::phoenix6::signals::ReverseLimitSourceValue;
using ctre::phoenix6::signals::ReverseLimitTypeValue;
using ctre::phoenix6::signals::InvertedValue;
using ctre::phoenix6::signals::NeutralModeValue;
using ctre::phoenix::motorcontrol::RemoteSensorSource;

noteManager_gen::noteManager_gen() : noteManagement ( MechanismTypes::MECHANISM_TYPE::NOTE_MANAGER, std::string ( "noteManager" ) ),
	m_motorMap(),
	m_solenoidMap(),
	m_servoMap()
{
}

void noteManager_gen::Create()
{
	m_ntName = "noteManager";

	DistanceAngleCalcStruc frontIntakeCalcStruct;
	frontIntakeCalcStruct.countsPerRev = 0 ;
	frontIntakeCalcStruct.gearRatio = 1 ;
	frontIntakeCalcStruct.diameter = units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() ;
	frontIntakeCalcStruct.countsPerInch = 0 ;
	frontIntakeCalcStruct.countsPerDegree = 0 ;;
	frontIntake = new DragonSparkMax ( 0,RobotElementNames::MOTOR_CONTROLLER_USAGE::NOTE_MANAGER_FRONT_INTAKE,rev::CANSparkMax::MotorType::kBrushless,rev::SparkRelativeEncoder::Type::kHallSensor,1 );
	m_motorMap[frontIntake->GetType()] = new BaseMechMotor ( m_ntName,
	    *frontIntake,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr );

	DistanceAngleCalcStruc backIntakeCalcStruct;
	backIntakeCalcStruct.countsPerRev = 0 ;
	backIntakeCalcStruct.gearRatio = 1 ;
	backIntakeCalcStruct.diameter = units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() ;
	backIntakeCalcStruct.countsPerInch = 0 ;
	backIntakeCalcStruct.countsPerDegree = 0 ;;
	backIntake = new DragonSparkMax ( 0,RobotElementNames::MOTOR_CONTROLLER_USAGE::NOTE_MANAGER_BACK_INTAKE,rev::CANSparkMax::MotorType::kBrushless,rev::SparkRelativeEncoder::Type::kHallSensor,1 );
	m_motorMap[backIntake->GetType()] = new BaseMechMotor ( m_ntName,
	    *backIntake,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr );

	DistanceAngleCalcStruc TransferCalcStruct;
	TransferCalcStruct.countsPerRev = 0 ;
	TransferCalcStruct.gearRatio = 1 ;
	TransferCalcStruct.diameter = units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() ;
	TransferCalcStruct.countsPerInch = 0 ;
	TransferCalcStruct.countsPerDegree = 0 ;;
	Transfer = new DragonSparkMax ( 0,RobotElementNames::MOTOR_CONTROLLER_USAGE::NOTE_MANAGER_TRANSFER,rev::CANSparkMax::MotorType::kBrushless,rev::SparkRelativeEncoder::Type::kHallSensor,1 );
	m_motorMap[Transfer->GetType()] = new BaseMechMotor ( m_ntName,
	    *Transfer,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr );

	DistanceAngleCalcStruc PlacerCalcStruct;
	PlacerCalcStruct.countsPerRev = 0 ;
	PlacerCalcStruct.gearRatio = 1 ;
	PlacerCalcStruct.diameter = units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() ;
	PlacerCalcStruct.countsPerInch = 0 ;
	PlacerCalcStruct.countsPerDegree = 0 ;;
	Placer = new DragonTalonFX ( "Placer",RobotElementNames::MOTOR_CONTROLLER_USAGE::NOTE_MANAGER_PLACER,0, PlacerCalcStruct, IDragonMotorController::MOTOR_TYPE::FALCON500, "rio" );
	m_motorMap[Placer->GetType()] = new BaseMechMotor ( m_ntName,
	    *Placer,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr );

	DistanceAngleCalcStruc ElevatorCalcStruct;
	ElevatorCalcStruct.countsPerRev = 0 ;
	ElevatorCalcStruct.gearRatio = 1 ;
	ElevatorCalcStruct.diameter = units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() ;
	ElevatorCalcStruct.countsPerInch = 0 ;
	ElevatorCalcStruct.countsPerDegree = 0 ;;
	Elevator = new DragonSparkFlex ( 0,RobotElementNames::MOTOR_CONTROLLER_USAGE::NOTE_MANAGER_ELEVATOR,rev::CANSparkFlex::MotorType::kBrushless,rev::SparkRelativeEncoder::Type::kHallSensor,1 );
	m_motorMap[Elevator->GetType()] = new BaseMechMotor ( m_ntName,
	    *Elevator,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr );

	DistanceAngleCalcStruc FeederCalcStruct;
	FeederCalcStruct.countsPerRev = 0 ;
	FeederCalcStruct.gearRatio = 1 ;
	FeederCalcStruct.diameter = units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() ;
	FeederCalcStruct.countsPerInch = 0 ;
	FeederCalcStruct.countsPerDegree = 0 ;;
	Feeder = new DragonSparkFlex ( 0,RobotElementNames::MOTOR_CONTROLLER_USAGE::NOTE_MANAGER_FEEDER,rev::CANSparkFlex::MotorType::kBrushless,rev::SparkRelativeEncoder::Type::kHallSensor,1 );
	m_motorMap[Feeder->GetType()] = new BaseMechMotor ( m_ntName,
	    *Feeder,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr );

	DistanceAngleCalcStruc launcherTopCalcStruct;
	launcherTopCalcStruct.countsPerRev = 0 ;
	launcherTopCalcStruct.gearRatio = 1 ;
	launcherTopCalcStruct.diameter = units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() ;
	launcherTopCalcStruct.countsPerInch = 0 ;
	launcherTopCalcStruct.countsPerDegree = 0 ;;
	launcherTop = new DragonTalonFX ( "launcherTop",RobotElementNames::MOTOR_CONTROLLER_USAGE::NOTE_MANAGER_LAUNCHER_TOP,0, launcherTopCalcStruct, IDragonMotorController::MOTOR_TYPE::FALCON500, "rio" );
	m_motorMap[launcherTop->GetType()] = new BaseMechMotor ( m_ntName,
	    *launcherTop,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr );

	DistanceAngleCalcStruc launcherBottomCalcStruct;
	launcherBottomCalcStruct.countsPerRev = 0 ;
	launcherBottomCalcStruct.gearRatio = 1 ;
	launcherBottomCalcStruct.diameter = units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() ;
	launcherBottomCalcStruct.countsPerInch = 0 ;
	launcherBottomCalcStruct.countsPerDegree = 0 ;;
	launcherBottom = new DragonTalonFX ( "launcherBottom",RobotElementNames::MOTOR_CONTROLLER_USAGE::NOTE_MANAGER_LAUNCHER_BOTTOM,0, launcherBottomCalcStruct, IDragonMotorController::MOTOR_TYPE::FALCON500, "rio" );
	m_motorMap[launcherBottom->GetType()] = new BaseMechMotor ( m_ntName,
	    *launcherBottom,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr );

	DistanceAngleCalcStruc launcherAngleCalcStruct;
	launcherAngleCalcStruct.countsPerRev = 0 ;
	launcherAngleCalcStruct.gearRatio = 1 ;
	launcherAngleCalcStruct.diameter = units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() ;
	launcherAngleCalcStruct.countsPerInch = 0 ;
	launcherAngleCalcStruct.countsPerDegree = 0 ;;
	launcherAngle = new DragonTalonSRX ( "launcherAngle",
	                                     RobotElementNames::MOTOR_CONTROLLER_USAGE::NOTE_MANAGER_LAUNCHER_ANGLE,
	                                     0,
	                                     0,
	                                     launcherAngleCalcStruct,
	                                     IDragonMotorController::MOTOR_TYPE::ANDYMARK9015 );
	m_motorMap[launcherAngle->GetType()] = new BaseMechMotor ( m_ntName,
	    *launcherAngle,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr );

	launcherAngleSensor = new DragonCanCoder ( "launcherAngleSensor",RobotElementNames::CANCODER_USAGE::NOTE_MANAGER_LAUNCHER_ANGLE_SENSOR,0,"rio",0,false );

	percentOutput = new ControlData (
	    ControlModes::CONTROL_TYPE::PERCENT_OUTPUT, // ControlModes::CONTROL_TYPE mode
	    ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
	    "percentOutput", // std::string indentifier
	    0, // double proportional
	    0, // double integral
	    0, // double derivative
	    0, // double feedforward
	    ControlData::FEEDFORWARD_TYPE::VOLTAGE, // FEEDFORWARD_TYPE feedforwadType
	    0, // double integralZone
	    0, // double maxAcceleration
	    0, // double cruiseVelocity
	    0, // double peakValue
	    0, // double nominalValue
	    false  // bool enableFOC
	);
	positionInch = new ControlData (
	    ControlModes::CONTROL_TYPE::POSITION_INCH, // ControlModes::CONTROL_TYPE mode
	    ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
	    "positionInch", // std::string indentifier
	    0, // double proportional
	    0, // double integral
	    0, // double derivative
	    0, // double feedforward
	    ControlData::FEEDFORWARD_TYPE::VOLTAGE, // FEEDFORWARD_TYPE feedforwadType
	    0, // double integralZone
	    0, // double maxAcceleration
	    0, // double cruiseVelocity
	    0, // double peakValue
	    0, // double nominalValue
	    false  // bool enableFOC
	);
	velocityRPS = new ControlData (
	    ControlModes::CONTROL_TYPE::VELOCITY_RPS, // ControlModes::CONTROL_TYPE mode
	    ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
	    "velocityRPS", // std::string indentifier
	    0, // double proportional
	    0, // double integral
	    0, // double derivative
	    0, // double feedforward
	    ControlData::FEEDFORWARD_TYPE::VOLTAGE, // FEEDFORWARD_TYPE feedforwadType
	    0, // double integralZone
	    0, // double maxAcceleration
	    0, // double cruiseVelocity
	    0, // double peakValue
	    0, // double nominalValue
	    false  // bool enableFOC
	);
	posDegreeAbs = new ControlData (
	    ControlModes::CONTROL_TYPE::POSITION_DEGREES_ABSOLUTE, // ControlModes::CONTROL_TYPE mode
	    ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
	    "posDegreeAbs", // std::string indentifier
	    0, // double proportional
	    0, // double integral
	    0, // double derivative
	    0, // double feedforward
	    ControlData::FEEDFORWARD_TYPE::VOLTAGE, // FEEDFORWARD_TYPE feedforwadType
	    0, // double integralZone
	    0, // double maxAcceleration
	    0, // double cruiseVelocity
	    0, // double peakValue
	    0, // double nominalValue
	    false  // bool enableFOC
	);

	noteManagerOffState* OffState = new noteManagerOffState ( string ( "Off" ), 0, new noteManagerOffStateGen ( string ( "Off" ), 0, this ) );
	AddToStateVector ( OffState );

	noteManagerReadyState* ReadyState = new noteManagerReadyState ( string ( "Ready" ), 1, new noteManagerReadyStateGen ( string ( "Ready" ), 1, this ) );
	AddToStateVector ( ReadyState );

	noteManagerfeederIntakeState* feederIntakeState = new noteManagerfeederIntakeState ( string ( "feederIntake" ), 2, new noteManagerfeederIntakeStateGen ( string ( "feederIntake" ), 2, this ) );
	AddToStateVector ( feederIntakeState );

	noteManagerExpelState* ExpelState = new noteManagerExpelState ( string ( "Expel" ), 3, new noteManagerExpelStateGen ( string ( "Expel" ), 3, this ) );
	AddToStateVector ( ExpelState );

	noteManagerplacerIntakeState* placerIntakeState = new noteManagerplacerIntakeState ( string ( "placerIntake" ), 4, new noteManagerplacerIntakeStateGen ( string ( "placerIntake" ), 4, this ) );
	AddToStateVector ( placerIntakeState );

	noteManagerholdFeederFrontState* holdFeederFrontState = new noteManagerholdFeederFrontState ( string ( "holdFeederFront" ), 5, new noteManagerholdFeederFrontStateGen ( string ( "holdFeederFront" ), 5, this ) );
	AddToStateVector ( holdFeederFrontState );

	noteManagerholdFeederBackState* holdFeederBackState = new noteManagerholdFeederBackState ( string ( "holdFeederBack" ), 6, new noteManagerholdFeederBackStateGen ( string ( "holdFeederBack" ), 6, this ) );
	AddToStateVector ( holdFeederBackState );

	noteManagerintakeToFeederState* intakeToFeederState = new noteManagerintakeToFeederState ( string ( "intakeToFeeder" ), 7, new noteManagerintakeToFeederStateGen ( string ( "intakeToFeeder" ), 7, this ) );
	AddToStateVector ( intakeToFeederState );

	noteManagerlauncherToPlacerFrontState* launcherToPlacerFrontState = new noteManagerlauncherToPlacerFrontState ( string ( "launcherToPlacerFront" ), 8, new noteManagerlauncherToPlacerFrontStateGen ( string ( "launcherToPlacerFront" ), 8, this ) );
	AddToStateVector ( launcherToPlacerFrontState );

	noteManagerlauncherToPlacerBackState* launcherToPlacerBackState = new noteManagerlauncherToPlacerBackState ( string ( "launcherToPlacerBack" ), 9, new noteManagerlauncherToPlacerBackStateGen ( string ( "launcherToPlacerBack" ), 9, this ) );
	AddToStateVector ( launcherToPlacerBackState );

	noteManagerholdFeederState* holdFeederState = new noteManagerholdFeederState ( string ( "holdFeeder" ), 10, new noteManagerholdFeederStateGen ( string ( "holdFeeder" ), 10, this ) );
	AddToStateVector ( holdFeederState );

	noteManagerreadyAutoLaunchState* readyAutoLaunchState = new noteManagerreadyAutoLaunchState ( string ( "readyAutoLaunch" ), 11, new noteManagerreadyAutoLaunchStateGen ( string ( "readyAutoLaunch" ), 11, this ) );
	AddToStateVector ( readyAutoLaunchState );

	noteManagerreadyManualLaunchState* readyManualLaunchState = new noteManagerreadyManualLaunchState ( string ( "readyManualLaunch" ), 12, new noteManagerreadyManualLaunchStateGen ( string ( "readyManualLaunch" ), 12, this ) );
	AddToStateVector ( readyManualLaunchState );

	noteManagerPassState* PassState = new noteManagerPassState ( string ( "Pass" ), 13, new noteManagerPassStateGen ( string ( "Pass" ), 13, this ) );
	AddToStateVector ( PassState );

	noteManagerautoLaunchState* autoLaunchState = new noteManagerautoLaunchState ( string ( "autoLaunch" ), 14, new noteManagerautoLaunchStateGen ( string ( "autoLaunch" ), 14, this ) );
	AddToStateVector ( autoLaunchState );

	noteManagermanualLaunchState* manualLaunchState = new noteManagermanualLaunchState ( string ( "manualLaunch" ), 15, new noteManagermanualLaunchStateGen ( string ( "manualLaunch" ), 15, this ) );
	AddToStateVector ( manualLaunchState );

	noteManagerreadyOdometryLaunchState* readyOdometryLaunchState = new noteManagerreadyOdometryLaunchState ( string ( "readyOdometryLaunch" ), 16, new noteManagerreadyOdometryLaunchStateGen ( string ( "readyOdometryLaunch" ), 16, this ) );
	AddToStateVector ( readyOdometryLaunchState );

	noteManagerautoLaunchOdometryState* autoLaunchOdometryState = new noteManagerautoLaunchOdometryState ( string ( "autoLaunchOdometry" ), 17, new noteManagerautoLaunchOdometryStateGen ( string ( "autoLaunchOdometry" ), 17, this ) );
	AddToStateVector ( autoLaunchOdometryState );

	noteManagerholdPlacerFrontState* holdPlacerFrontState = new noteManagerholdPlacerFrontState ( string ( "holdPlacerFront" ), 18, new noteManagerholdPlacerFrontStateGen ( string ( "holdPlacerFront" ), 18, this ) );
	AddToStateVector ( holdPlacerFrontState );

	noteManagerholdPlacerBackState* holdPlacerBackState = new noteManagerholdPlacerBackState ( string ( "holdPlacerBack" ), 19, new noteManagerholdPlacerBackStateGen ( string ( "holdPlacerBack" ), 19, this ) );
	AddToStateVector ( holdPlacerBackState );

	noteManagerintakeToPlacerState* intakeToPlacerState = new noteManagerintakeToPlacerState ( string ( "intakeToPlacer" ), 20, new noteManagerintakeToPlacerStateGen ( string ( "intakeToPlacer" ), 20, this ) );
	AddToStateVector ( intakeToPlacerState );

	noteManagerpreparePlaceAmpState* preparePlaceAmpState = new noteManagerpreparePlaceAmpState ( string ( "preparePlaceAmp" ), 21, new noteManagerpreparePlaceAmpStateGen ( string ( "preparePlaceAmp" ), 21, this ) );
	AddToStateVector ( preparePlaceAmpState );

	noteManagerpreparePlaceTrapState* preparePlaceTrapState = new noteManagerpreparePlaceTrapState ( string ( "preparePlaceTrap" ), 22, new noteManagerpreparePlaceTrapStateGen ( string ( "preparePlaceTrap" ), 22, this ) );
	AddToStateVector ( preparePlaceTrapState );

	noteManagerplaceAmpState* placeAmpState = new noteManagerplaceAmpState ( string ( "placeAmp" ), 23, new noteManagerplaceAmpStateGen ( string ( "placeAmp" ), 23, this ) );
	AddToStateVector ( placeAmpState );

	noteManagerplaceTrapState* placeTrapState = new noteManagerplaceTrapState ( string ( "placeTrap" ), 24, new noteManagerplaceTrapStateGen ( string ( "placeTrap" ), 24, this ) );
	AddToStateVector ( placeTrapState );

	noteManagerplacerToLauncherFrontState* placerToLauncherFrontState = new noteManagerplacerToLauncherFrontState ( string ( "placerToLauncherFront" ), 25, new noteManagerplacerToLauncherFrontStateGen ( string ( "placerToLauncherFront" ), 25, this ) );
	AddToStateVector ( placerToLauncherFrontState );

	noteManagerplacerToLauncherBackState* placerToLauncherBackState = new noteManagerplacerToLauncherBackState ( string ( "placerToLauncherBack" ), 26, new noteManagerplacerToLauncherBackStateGen ( string ( "placerToLauncherBack" ), 26, this ) );
	AddToStateVector ( placerToLauncherBackState );

	noteManagerbackupManualLaunchState* backupManualLaunchState = new noteManagerbackupManualLaunchState ( string ( "backupManualLaunch" ), 27, new noteManagerbackupManualLaunchStateGen ( string ( "backupManualLaunch" ), 27, this ) );
	AddToStateVector ( backupManualLaunchState );

	noteManagerbackupManualPlaceState* backupManualPlaceState = new noteManagerbackupManualPlaceState ( string ( "backupManualPlace" ), 28, new noteManagerbackupManualPlaceStateGen ( string ( "backupManualPlace" ), 28, this ) );
	AddToStateVector ( backupManualPlaceState );

	OffState->RegisterTransitionState ( ReadyState );
	ReadyState->RegisterTransitionState ( feederIntakeState );
	ReadyState->RegisterTransitionState ( ExpelState );
	ReadyState->RegisterTransitionState ( placerIntakeState );
	ReadyState->RegisterTransitionState ( backupManualLaunchState );
	ReadyState->RegisterTransitionState ( backupManualPlaceState );
	feederIntakeState->RegisterTransitionState ( ReadyState );
	feederIntakeState->RegisterTransitionState ( holdFeederFrontState );
	feederIntakeState->RegisterTransitionState ( holdFeederBackState );
	feederIntakeState->RegisterTransitionState ( ExpelState );
	ExpelState->RegisterTransitionState ( ReadyState );
	ExpelState->RegisterTransitionState ( feederIntakeState );
	ExpelState->RegisterTransitionState ( placerIntakeState );
	placerIntakeState->RegisterTransitionState ( ReadyState );
	placerIntakeState->RegisterTransitionState ( holdPlacerFrontState );
	placerIntakeState->RegisterTransitionState ( holdPlacerBackState );
	holdFeederFrontState->RegisterTransitionState ( ReadyState );
	holdFeederFrontState->RegisterTransitionState ( launcherToPlacerFrontState );
	holdFeederFrontState->RegisterTransitionState ( intakeToFeederState );
	holdFeederBackState->RegisterTransitionState ( ReadyState );
	holdFeederBackState->RegisterTransitionState ( intakeToFeederState );
	holdFeederBackState->RegisterTransitionState ( launcherToPlacerBackState );
	intakeToFeederState->RegisterTransitionState ( ReadyState );
	intakeToFeederState->RegisterTransitionState ( holdFeederState );
	launcherToPlacerFrontState->RegisterTransitionState ( ReadyState );
	launcherToPlacerFrontState->RegisterTransitionState ( placerIntakeState );
	launcherToPlacerBackState->RegisterTransitionState ( ReadyState );
	launcherToPlacerBackState->RegisterTransitionState ( holdPlacerBackState );
	holdFeederState->RegisterTransitionState ( ReadyState );
	holdFeederState->RegisterTransitionState ( readyAutoLaunchState );
	holdFeederState->RegisterTransitionState ( readyManualLaunchState );
	holdFeederState->RegisterTransitionState ( PassState );
	readyAutoLaunchState->RegisterTransitionState ( ReadyState );
	readyAutoLaunchState->RegisterTransitionState ( holdFeederState );
	readyAutoLaunchState->RegisterTransitionState ( autoLaunchState );
	readyManualLaunchState->RegisterTransitionState ( ReadyState );
	readyManualLaunchState->RegisterTransitionState ( manualLaunchState );
	PassState->RegisterTransitionState ( ReadyState );
	autoLaunchState->RegisterTransitionState ( ReadyState );
	manualLaunchState->RegisterTransitionState ( ReadyState );
	readyOdometryLaunchState->RegisterTransitionState ( ReadyState );
	readyOdometryLaunchState->RegisterTransitionState ( readyAutoLaunchState );
	readyOdometryLaunchState->RegisterTransitionState ( autoLaunchOdometryState );
	autoLaunchOdometryState->RegisterTransitionState ( ReadyState );
	holdPlacerFrontState->RegisterTransitionState ( ReadyState );
	holdPlacerFrontState->RegisterTransitionState ( intakeToPlacerState );
	holdPlacerFrontState->RegisterTransitionState ( placerToLauncherFrontState );
	holdPlacerBackState->RegisterTransitionState ( ReadyState );
	holdPlacerBackState->RegisterTransitionState ( placerToLauncherBackState );
	holdPlacerBackState->RegisterTransitionState ( intakeToPlacerState );
	intakeToPlacerState->RegisterTransitionState ( ReadyState );
	intakeToPlacerState->RegisterTransitionState ( preparePlaceAmpState );
	intakeToPlacerState->RegisterTransitionState ( preparePlaceTrapState );
	preparePlaceAmpState->RegisterTransitionState ( ReadyState );
	preparePlaceAmpState->RegisterTransitionState ( preparePlaceTrapState );
	preparePlaceAmpState->RegisterTransitionState ( placeAmpState );
	preparePlaceTrapState->RegisterTransitionState ( ReadyState );
	preparePlaceTrapState->RegisterTransitionState ( preparePlaceAmpState );
	preparePlaceTrapState->RegisterTransitionState ( placeTrapState );
	placeAmpState->RegisterTransitionState ( ReadyState );
	placeTrapState->RegisterTransitionState ( ReadyState );
	placerToLauncherFrontState->RegisterTransitionState ( ReadyState );
	placerToLauncherFrontState->RegisterTransitionState ( feederIntakeState );
	placerToLauncherBackState->RegisterTransitionState ( ReadyState );
	placerToLauncherBackState->RegisterTransitionState ( holdFeederBackState );
	backupManualLaunchState->RegisterTransitionState ( ReadyState );
	backupManualPlaceState->RegisterTransitionState ( ReadyState );

	m_table = nt::NetworkTableInstance::GetDefault().GetTable ( m_ntName );
	m_tuningIsEnabledStr = "Enable Tuning for " + m_ntName; // since this string is used every loop, we do not want to create the string every time
	m_table.get()->PutBoolean ( m_tuningIsEnabledStr, m_tuning );
}

void noteManager_gen::Initialize ( RobotConfigMgr::RobotIdentifier robotFullName )
{
	if ( false ) {}
	else if ( RobotConfigMgr::RobotIdentifier::practiceBot_9999 == robotFullName )
	{

		frontIntake->SetRemoteSensor ( 0,
		                               ctre::phoenix::motorcontrol::RemoteSensorSource::RemoteSensorSource_Off );
		frontIntake->Invert ( true );
		frontIntake->EnableBrakeMode ( true );
		frontIntake->EnableCurrentLimiting ( false );
		frontIntake->SetDiameter ( units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() );
// frontIntake : Follower motor mode is not enabled
		frontIntake->SetVoltageRamping ( units::time::second_t ( units::time::second_t ( 0 ) ).to<double>(),
		                                 units::time::second_t ( units::time::second_t ( 0 ) ).to<double>() );
		frontIntake->SetSensorInverted ( false );

		backIntake->SetRemoteSensor ( 0,
		                              ctre::phoenix::motorcontrol::RemoteSensorSource::RemoteSensorSource_Off );
		backIntake->Invert ( true );
		backIntake->EnableBrakeMode ( true );
		backIntake->EnableCurrentLimiting ( false );
		backIntake->SetDiameter ( units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() );
// backIntake : Follower motor mode is not enabled
		backIntake->SetVoltageRamping ( units::time::second_t ( units::time::second_t ( 0 ) ).to<double>(),
		                                units::time::second_t ( units::time::second_t ( 0 ) ).to<double>() );
		backIntake->SetSensorInverted ( false );

		Transfer->SetRemoteSensor ( 0,
		                            ctre::phoenix::motorcontrol::RemoteSensorSource::RemoteSensorSource_Off );
		Transfer->Invert ( true );
		Transfer->EnableBrakeMode ( true );
		Transfer->EnableCurrentLimiting ( false );
		Transfer->SetDiameter ( units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() );
// Transfer : Follower motor mode is not enabled
		Transfer->SetVoltageRamping ( units::time::second_t ( units::time::second_t ( 0 ) ).to<double>(),
		                              units::time::second_t ( units::time::second_t ( 0 ) ).to<double>() );
		Transfer->SetSensorInverted ( false );

		Placer->SetCurrentLimits ( false,
		                           units::current::ampere_t ( 0 ),
		                           false,
		                           units::current::ampere_t ( 0 ),
		                           units::current::ampere_t ( 0 ),
		                           units::time::second_t ( 0 ) );
		Placer->ConfigHWLimitSW ( false, // enableForward
		                          0, // remoteForwardSensorID
		                          false, // forwardResetPosition
		                          0, // forwardPosition
		                          ForwardLimitSourceValue::LimitSwitchPin, // forwardType
		                          ForwardLimitTypeValue::NormallyOpen, // forwardOpenClose
		                          false, // enableReverse
		                          0, // remoteReverseSensorID
		                          false, // reverseResetPosition
		                          0, // reversePosition
		                          ReverseLimitSourceValue::LimitSwitchPin, // revType
		                          ReverseLimitTypeValue::NormallyOpen ); // revOpenClose
		Placer->ConfigMotorSettings ( ctre::phoenix6::signals::InvertedValue::CounterClockwise_Positive, // ctre::phoenixpro::signals::InvertedValue
		                              ctre::phoenix6::signals::NeutralModeValue::Brake, // ctre::phoenixpro::signals::NeutralModeValue
		                              0, // deadbandPercent
		                              0, // peakForwardDutyCycle
		                              0 ); // peakReverseDutyCycle
		Placer->SetAsFollowerMotor ( 0 ); // masterCANID
		Placer->SetRemoteSensor ( 0, // canID
		                          RemoteSensorSource::RemoteSensorSource_Off ); // ctre::phoenix::motorcontrol::RemoteSensorSource
		Placer->SetDiameter ( 0 ); // double diameter
		Placer->SetVoltageRamping ( units::time::second_t ( units::time::second_t ( 0 ) ).to<double>(),
		                            units::time::second_t ( units::time::second_t ( 0 ) ).to<double>() );
		Placer->SetSensorInverted ( false );
		Elevator->SetRemoteSensor ( 0,
		                            ctre::phoenix::motorcontrol::RemoteSensorSource::RemoteSensorSource_Off );
		Elevator->Invert ( true );
		Elevator->EnableBrakeMode ( true );
		Elevator->EnableCurrentLimiting ( false );
		Elevator->SetDiameter ( units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() );
// Elevator : Follower motor mode is not enabled
		Elevator->SetVoltageRamping ( units::time::second_t ( units::time::second_t ( 0 ) ).to<double>(),
		                              units::time::second_t ( units::time::second_t ( 0 ) ).to<double>() );
		Elevator->SetSensorInverted ( false );

		Feeder->SetRemoteSensor ( 0,
		                          ctre::phoenix::motorcontrol::RemoteSensorSource::RemoteSensorSource_Off );
		Feeder->Invert ( true );
		Feeder->EnableBrakeMode ( true );
		Feeder->EnableCurrentLimiting ( false );
		Feeder->SetDiameter ( units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() );
// Feeder : Follower motor mode is not enabled
		Feeder->SetVoltageRamping ( units::time::second_t ( units::time::second_t ( 0 ) ).to<double>(),
		                            units::time::second_t ( units::time::second_t ( 0 ) ).to<double>() );
		Feeder->SetSensorInverted ( false );

		launcherTop->SetCurrentLimits ( false,
		                                units::current::ampere_t ( 0 ),
		                                false,
		                                units::current::ampere_t ( 0 ),
		                                units::current::ampere_t ( 0 ),
		                                units::time::second_t ( 0 ) );
		launcherTop->ConfigHWLimitSW ( false, // enableForward
		                               0, // remoteForwardSensorID
		                               false, // forwardResetPosition
		                               0, // forwardPosition
		                               ForwardLimitSourceValue::LimitSwitchPin, // forwardType
		                               ForwardLimitTypeValue::NormallyOpen, // forwardOpenClose
		                               false, // enableReverse
		                               0, // remoteReverseSensorID
		                               false, // reverseResetPosition
		                               0, // reversePosition
		                               ReverseLimitSourceValue::LimitSwitchPin, // revType
		                               ReverseLimitTypeValue::NormallyOpen ); // revOpenClose
		launcherTop->ConfigMotorSettings ( ctre::phoenix6::signals::InvertedValue::CounterClockwise_Positive, // ctre::phoenixpro::signals::InvertedValue
		                                   ctre::phoenix6::signals::NeutralModeValue::Brake, // ctre::phoenixpro::signals::NeutralModeValue
		                                   0, // deadbandPercent
		                                   0, // peakForwardDutyCycle
		                                   0 ); // peakReverseDutyCycle
		launcherTop->SetAsFollowerMotor ( 0 ); // masterCANID
		launcherTop->SetRemoteSensor ( 0, // canID
		                               RemoteSensorSource::RemoteSensorSource_Off ); // ctre::phoenix::motorcontrol::RemoteSensorSource
		launcherTop->SetDiameter ( 0 ); // double diameter
		launcherTop->SetVoltageRamping ( units::time::second_t ( units::time::second_t ( 0 ) ).to<double>(),
		                                 units::time::second_t ( units::time::second_t ( 0 ) ).to<double>() );
		launcherTop->SetSensorInverted ( false );
		launcherBottom->SetCurrentLimits ( false,
		                                   units::current::ampere_t ( 0 ),
		                                   false,
		                                   units::current::ampere_t ( 0 ),
		                                   units::current::ampere_t ( 0 ),
		                                   units::time::second_t ( 0 ) );
		launcherBottom->ConfigHWLimitSW ( false, // enableForward
		                                  0, // remoteForwardSensorID
		                                  false, // forwardResetPosition
		                                  0, // forwardPosition
		                                  ForwardLimitSourceValue::LimitSwitchPin, // forwardType
		                                  ForwardLimitTypeValue::NormallyOpen, // forwardOpenClose
		                                  false, // enableReverse
		                                  0, // remoteReverseSensorID
		                                  false, // reverseResetPosition
		                                  0, // reversePosition
		                                  ReverseLimitSourceValue::LimitSwitchPin, // revType
		                                  ReverseLimitTypeValue::NormallyOpen ); // revOpenClose
		launcherBottom->ConfigMotorSettings ( ctre::phoenix6::signals::InvertedValue::CounterClockwise_Positive, // ctre::phoenixpro::signals::InvertedValue
		                                      ctre::phoenix6::signals::NeutralModeValue::Brake, // ctre::phoenixpro::signals::NeutralModeValue
		                                      0, // deadbandPercent
		                                      0, // peakForwardDutyCycle
		                                      0 ); // peakReverseDutyCycle
		launcherBottom->SetAsFollowerMotor ( 0 ); // masterCANID
		launcherBottom->SetRemoteSensor ( 0, // canID
		                                  RemoteSensorSource::RemoteSensorSource_Off ); // ctre::phoenix::motorcontrol::RemoteSensorSource
		launcherBottom->SetDiameter ( 0 ); // double diameter
		launcherBottom->SetVoltageRamping ( units::time::second_t ( units::time::second_t ( 0 ) ).to<double>(),
		                                    units::time::second_t ( units::time::second_t ( 0 ) ).to<double>() );
		launcherBottom->SetSensorInverted ( false );
		launcherAngle->SetRemoteSensor ( 0,
		                                 ctre::phoenix::motorcontrol::RemoteSensorSource::RemoteSensorSource_CANCoder );
		launcherAngle->Invert ( true );
		launcherAngle->EnableBrakeMode ( true );
		launcherAngle->EnableCurrentLimiting ( false );
		launcherAngle->ConfigPeakCurrentLimit ( units::current::ampere_t ( units::current::ampere_t ( 0 ) ).to<int>(),
		                                        units::time::millisecond_t ( units::time::second_t ( 0 ) ).to<int>() );
		launcherAngle->ConfigPeakCurrentDuration ( units::time::millisecond_t ( units::time::second_t ( 0 ) ).to<int>(),
		        units::time::millisecond_t ( units::time::second_t ( 0 ) ).to<int>() );
		launcherAngle->ConfigContinuousCurrentLimit ( units::current::ampere_t ( units::current::ampere_t ( 0 ) ).to<int>(),
		        units::time::millisecond_t ( units::time::second_t ( 0 ) ).to<int>() );
		launcherAngle->SetDiameter ( units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() );
		launcherAngle->EnableDisableLimitSwitches ( true );
		launcherAngle->SetForwardLimitSwitch ( true );
		launcherAngle->SetReverseLimitSwitch ( true );
// launcherAngle : Follower motor mode is not enabled
		launcherAngle->SetVoltageRamping ( units::time::second_t ( units::time::second_t ( 0 ) ).to<double>(),
		                                   units::time::second_t ( units::time::second_t ( 0 ) ).to<double>() );
		launcherAngle->SetSensorInverted ( false );

// frontIntakeSensor : Digital inputs do not have initialization needs
// backIntakeSensor : Digital inputs do not have initialization needs
// feederSensor : Digital inputs do not have initialization needs
// launcherSensor : Digital inputs do not have initialization needs
// placerInSensor : Digital inputs do not have initialization needs
// placerMidSensor : Digital inputs do not have initialization needs
// placerOutSensor : Digital inputs do not have initialization needs

// launcherAngleSensor : CANcoder inputs do not have initialization needs

// percentOutput : ControlData does not have initialization needs
// positionInch : ControlData does not have initialization needs
// velocityRPS : ControlData does not have initialization needs
// posDegreeAbs : ControlData does not have initialization needs

//todo create initialization for Off
//todo create initialization for Ready
//todo create initialization for feederIntake
//todo create initialization for Expel
//todo create initialization for placerIntake
//todo create initialization for holdFeederFront
//todo create initialization for holdFeederBack
//todo create initialization for intakeToFeeder
//todo create initialization for launcherToPlacerFront
//todo create initialization for launcherToPlacerBack
//todo create initialization for holdFeeder
//todo create initialization for readyAutoLaunch
//todo create initialization for readyManualLaunch
//todo create initialization for Pass
//todo create initialization for autoLaunch
//todo create initialization for manualLaunch
//todo create initialization for readyOdometryLaunch
//todo create initialization for autoLaunchOdometry
//todo create initialization for holdPlacerFront
//todo create initialization for holdPlacerBack
//todo create initialization for intakeToPlacer
//todo create initialization for preparePlaceAmp
//todo create initialization for preparePlaceTrap
//todo create initialization for placeAmp
//todo create initialization for placeTrap
//todo create initialization for placerToLauncherFront
//todo create initialization for placerToLauncherBack
//todo create initialization for backupManualLaunch
//todo create initialization for backupManualPlace
	}

}

/// @brief  Set the control constants (e.g. PIDF values).
/// @param [in] ControlData*                                   pid:  the control constants
/// @return void
void noteManager_gen::SetControlConstants ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, int slot, ControlData pid )
{
	auto motor = GetMotorMech ( identifier );
	if ( motor != nullptr )
	{
		motor->SetControlConstants ( slot, pid );
	}
}

/// @brief update the output to the mechanism using the current controller and target value(s)
/// @return void
void noteManager_gen::Update()
{
	for ( auto motor : m_motorMap )
	{
		motor.second->Update();
	}
}

void noteManager_gen::UpdateTarget ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, double percentOutput )
{
	auto motor = GetMotorMech ( identifier );
	if ( motor != nullptr )
	{
		motor->UpdateTarget ( percentOutput );
	}
}

void noteManager_gen::UpdateTarget ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, units::angle::degree_t angle )
{
	auto motor = GetMotorMech ( identifier );
	if ( motor != nullptr )
	{
		motor->UpdateTarget ( angle );
	}
}

void noteManager_gen::UpdateTarget ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, units::angular_velocity::revolutions_per_minute_t angVel )
{
	auto motor = GetMotorMech ( identifier );
	if ( motor != nullptr )
	{
		motor->UpdateTarget ( angVel );
	}
}
void noteManager_gen::UpdateTarget ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, units::length::inch_t position )
{
	auto motor = GetMotorMech ( identifier );
	if ( motor != nullptr )
	{
		motor->UpdateTarget ( position );
	}
}
void noteManager_gen::UpdateTarget ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, units::velocity::feet_per_second_t velocity )
{
	auto motor = GetMotorMech ( identifier );
	if ( motor != nullptr )
	{
		motor->UpdateTarget ( velocity );
	}
}

bool noteManager_gen::IsAtMinPosition ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier ) const
{
	auto motor = GetMotorMech ( identifier );
	if ( motor != nullptr )
	{
		return motor->IsAtMinTravel();
	}
	return false;
}

bool noteManager_gen::IsAtMaxPosition ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier ) const
{
	auto motor = GetMotorMech ( identifier );
	if ( motor != nullptr )
	{
		return motor->IsAtMaxTravel();
	}
	return false;
}

BaseMechMotor *noteManager_gen::GetMotorMech ( RobotElementNames::MOTOR_CONTROLLER_USAGE usage ) const
{
	auto itr = m_motorMap.find ( usage );
	if ( itr != m_motorMap.end() )
	{
		return itr->second;
	}
	return nullptr;
}

std::vector<RobotElementNames::MOTOR_CONTROLLER_USAGE> noteManager_gen::GetMotorUsages() const
{
	std::vector<RobotElementNames::MOTOR_CONTROLLER_USAGE> output;
	for ( auto itr = m_motorMap.begin(); itr != m_motorMap.end(); ++itr )
	{
		output.emplace_back ( itr->first );
	}
	return output;
}

void noteManager_gen::UpdateTarget ( RobotElementNames::SOLENOID_USAGE identifier, bool extend )
{
	auto sol = GetSolenoidMech ( identifier );
	if ( sol != nullptr )
	{
		sol->ActivateSolenoid ( extend );
	}
}

bool noteManager_gen::IsAtMinPosition ( RobotElementNames::SOLENOID_USAGE identifier ) const
{
	auto sol = GetSolenoidMech ( identifier );
	if ( sol != nullptr )
	{
		return !sol->IsSolenoidActivated();
	}
	return false;
}

bool noteManager_gen::IsAtMaxPosition ( RobotElementNames::SOLENOID_USAGE identifier ) const
{
	auto sol = GetSolenoidMech ( identifier );
	if ( sol != nullptr )
	{
		return sol->IsSolenoidActivated();
	}
	return false;
}

BaseMechSolenoid *noteManager_gen::GetSolenoidMech ( RobotElementNames::SOLENOID_USAGE usage ) const
{
	auto itr = m_solenoidMap.find ( usage );
	if ( itr != m_solenoidMap.end() )
	{
		return itr->second;
	}
	return nullptr;
}

std::vector<RobotElementNames::SOLENOID_USAGE> noteManager_gen::GetSolenoidUsages() const
{
	std::vector<RobotElementNames::SOLENOID_USAGE> output;
	for ( auto itr = m_solenoidMap.begin(); itr != m_solenoidMap.end(); ++itr )
	{
		output.emplace_back ( itr->first );
	}
	return output;
}

BaseMechServo *noteManager_gen::GetServoMech ( RobotElementNames::SERVO_USAGE usage ) const
{
	auto itr = m_servoMap.find ( usage );
	if ( itr != m_servoMap.end() )
	{
		return itr->second;
	}
	return nullptr;
}

std::vector<RobotElementNames::SERVO_USAGE> noteManager_gen::GetServoUsages() const
{
	std::vector<RobotElementNames::SERVO_USAGE> output;
	for ( auto itr = m_servoMap.begin(); itr != m_servoMap.end(); ++itr )
	{
		output.emplace_back ( itr->first );
	}
	return output;
}
