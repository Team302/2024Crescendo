// clang-format off
//====================================================================================================================================================
// Copyright 2024 Lake Orion Robotics FIRST Team 302
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
// OR OTHER DEALINGS IN THE SOFTWARE.
//====================================================================================================================================================
// This file was automatically generated by the Team 302 code generator version 1.3.0.15
// Generated on Wednesday, September 18, 2024 9:14:53 AM

#include <string>

// FRC Includes
#include <networktables/NetworkTableInstance.h>
#include "hw/interfaces/IDragonMotorController.h"

#include "noteManagerGen.h"
#include "utils/logging/Logger.h"

using ctre::phoenix6::signals::ForwardLimitSourceValue;
using ctre::phoenix6::signals::ForwardLimitTypeValue;
using ctre::phoenix6::signals::ReverseLimitSourceValue;
using ctre::phoenix6::signals::ReverseLimitTypeValue;
using ctre::phoenix6::signals::InvertedValue;
using ctre::phoenix6::signals::NeutralModeValue;
using ctre::phoenix::motorcontrol::RemoteSensorSource;

noteManagerGen::noteManagerGen ( RobotConfigMgr::RobotIdentifier activeRobotId ) : BaseMech ( MechanismTypes::MECHANISM_TYPE::NOTE_MANAGER, "", std::string ( "noteManager" ) ),
	m_activeRobotId ( activeRobotId ),
	m_motorMap(),
	m_solenoidMap(),
	m_servoMap(),
	m_stateMap()
{
}

std::map<std::string, noteManagerGen::STATE_NAMES> noteManagerGen::stringToSTATE_NAMESEnumMap
{
	{"STATE_OFF", noteManagerGen::STATE_NAMES::STATE_OFF},
	{"STATE_READY", noteManagerGen::STATE_NAMES::STATE_READY},
	{"STATE_FEEDER_INTAKE", noteManagerGen::STATE_NAMES::STATE_FEEDER_INTAKE},
	{"STATE_EXPEL", noteManagerGen::STATE_NAMES::STATE_EXPEL},
	{"STATE_PLACER_INTAKE", noteManagerGen::STATE_NAMES::STATE_PLACER_INTAKE},
	{"STATE_HOLD_FEEDER", noteManagerGen::STATE_NAMES::STATE_HOLD_FEEDER},
	{"STATE_READY_AUTO_LAUNCH", noteManagerGen::STATE_NAMES::STATE_READY_AUTO_LAUNCH},
	{"STATE_READY_MANUAL_LAUNCH", noteManagerGen::STATE_NAMES::STATE_READY_MANUAL_LAUNCH},
	{"STATE_PASS", noteManagerGen::STATE_NAMES::STATE_PASS},
	{"STATE_AUTO_LAUNCH", noteManagerGen::STATE_NAMES::STATE_AUTO_LAUNCH},
	{"STATE_MANUAL_LAUNCH", noteManagerGen::STATE_NAMES::STATE_MANUAL_LAUNCH},
	{"STATE_READY_ODOMETRY_LAUNCH", noteManagerGen::STATE_NAMES::STATE_READY_ODOMETRY_LAUNCH},
	{"STATE_PREPARE_PLACE_AMP", noteManagerGen::STATE_NAMES::STATE_PREPARE_PLACE_AMP},
	{"STATE_PREPARE_PLACE_TRAP", noteManagerGen::STATE_NAMES::STATE_PREPARE_PLACE_TRAP},
	{"STATE_PLACE_AMP", noteManagerGen::STATE_NAMES::STATE_PLACE_AMP},
	{"STATE_PLACE_TRAP", noteManagerGen::STATE_NAMES::STATE_PLACE_TRAP},
	{"STATE_HOLD_PLACER", noteManagerGen::STATE_NAMES::STATE_HOLD_PLACER},
	{"STATE_READY_PASS", noteManagerGen::STATE_NAMES::STATE_READY_PASS},};

void noteManagerGen::CreateCompBot302()
{
	m_ntName = "noteManager";
	DistanceAngleCalcStruc frontIntakeCalcStruct;
	frontIntakeCalcStruct.countsPerRev = 0 ;
	frontIntakeCalcStruct.gearRatio = 1 ;
	frontIntakeCalcStruct.diameter = units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() ;
	frontIntakeCalcStruct.countsPerInch = 0 ;
	frontIntakeCalcStruct.countsPerDegree = 0 ;

	frontIntakeDragonSparkMaxMonitored = new DragonSparkMaxMonitored ( 5,RobotElementNames::MOTOR_CONTROLLER_USAGE::NOTE_MANAGER_FRONT_INTAKE,rev::CANSparkMax::MotorType::kBrushless,rev::SparkRelativeEncoder::Type::kHallSensor,rev::SparkLimitSwitch::Type::kNormallyOpen,rev::SparkLimitSwitch::Type::kNormallyOpen,frontIntakeCalcStruct );

	m_motorMap[frontIntakeDragonSparkMaxMonitored->GetType()] = new BaseMechMotor ( m_ntName,
	    frontIntakeDragonSparkMaxMonitored,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr );
	DistanceAngleCalcStruc backIntakeCalcStruct;
	backIntakeCalcStruct.countsPerRev = 0 ;
	backIntakeCalcStruct.gearRatio = 1 ;
	backIntakeCalcStruct.diameter = units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() ;
	backIntakeCalcStruct.countsPerInch = 0 ;
	backIntakeCalcStruct.countsPerDegree = 0 ;

	backIntakeDragonSparkMaxMonitored = new DragonSparkMaxMonitored ( 19,RobotElementNames::MOTOR_CONTROLLER_USAGE::NOTE_MANAGER_BACK_INTAKE,rev::CANSparkMax::MotorType::kBrushless,rev::SparkRelativeEncoder::Type::kHallSensor,rev::SparkLimitSwitch::Type::kNormallyOpen,rev::SparkLimitSwitch::Type::kNormallyOpen,backIntakeCalcStruct );

	m_motorMap[backIntakeDragonSparkMaxMonitored->GetType()] = new BaseMechMotor ( m_ntName,
	    backIntakeDragonSparkMaxMonitored,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr );
	DistanceAngleCalcStruc TransferCalcStruct;
	TransferCalcStruct.countsPerRev = 0 ;
	TransferCalcStruct.gearRatio = 1 ;
	TransferCalcStruct.diameter = units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() ;
	TransferCalcStruct.countsPerInch = 0 ;
	TransferCalcStruct.countsPerDegree = 0 ;

	TransferDragonSparkMaxMonitored = new DragonSparkMaxMonitored ( 6,RobotElementNames::MOTOR_CONTROLLER_USAGE::NOTE_MANAGER_TRANSFER,rev::CANSparkMax::MotorType::kBrushless,rev::SparkRelativeEncoder::Type::kHallSensor,rev::SparkLimitSwitch::Type::kNormallyOpen,rev::SparkLimitSwitch::Type::kNormallyOpen,TransferCalcStruct );

	m_motorMap[TransferDragonSparkMaxMonitored->GetType()] = new BaseMechMotor ( m_ntName,
	    TransferDragonSparkMaxMonitored,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr );
	DistanceAngleCalcStruc FeederCalcStruct;
	FeederCalcStruct.countsPerRev = 0 ;
	FeederCalcStruct.gearRatio = 1 ;
	FeederCalcStruct.diameter = units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() ;
	FeederCalcStruct.countsPerInch = 0 ;
	FeederCalcStruct.countsPerDegree = 0 ;

	FeederDragonSparkFlexMonitored = new DragonSparkFlexMonitored ( 2,RobotElementNames::MOTOR_CONTROLLER_USAGE::NOTE_MANAGER_FEEDER,rev::CANSparkFlex::MotorType::kBrushless,rev::SparkRelativeEncoder::Type::kHallSensor,rev::SparkLimitSwitch::Type::kNormallyOpen,rev::SparkLimitSwitch::Type::kNormallyOpen,FeederCalcStruct );

	m_motorMap[FeederDragonSparkFlexMonitored->GetType()] = new BaseMechMotor ( m_ntName,
	    FeederDragonSparkFlexMonitored,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr );
	DistanceAngleCalcStruc launcherTopCalcStruct;
	launcherTopCalcStruct.countsPerRev = 0 ;
	launcherTopCalcStruct.gearRatio = 1 ;
	launcherTopCalcStruct.diameter = units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() ;
	launcherTopCalcStruct.countsPerInch = 0 ;
	launcherTopCalcStruct.countsPerDegree = 0 ;

	launcherTopDragonTalonFX = new DragonTalonFX ( "launcherTop",RobotElementNames::MOTOR_CONTROLLER_USAGE::NOTE_MANAGER_LAUNCHER_TOP,11, launcherTopCalcStruct, IDragonMotorController::MOTOR_TYPE::FALCON500, "rio" );

	m_motorMap[launcherTopDragonTalonFX->GetType()] = new BaseMechMotor ( m_ntName,
	    launcherTopDragonTalonFX,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr );
	DistanceAngleCalcStruc launcherBottomCalcStruct;
	launcherBottomCalcStruct.countsPerRev = 0 ;
	launcherBottomCalcStruct.gearRatio = 1 ;
	launcherBottomCalcStruct.diameter = units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() ;
	launcherBottomCalcStruct.countsPerInch = 0 ;
	launcherBottomCalcStruct.countsPerDegree = 0 ;

	launcherBottomDragonTalonFX = new DragonTalonFX ( "launcherBottom",RobotElementNames::MOTOR_CONTROLLER_USAGE::NOTE_MANAGER_LAUNCHER_BOTTOM,10, launcherBottomCalcStruct, IDragonMotorController::MOTOR_TYPE::FALCON500, "rio" );

	m_motorMap[launcherBottomDragonTalonFX->GetType()] = new BaseMechMotor ( m_ntName,
	    launcherBottomDragonTalonFX,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr );
	DistanceAngleCalcStruc launcherAngleCalcStruct;
	launcherAngleCalcStruct.countsPerRev = 0 ;
	launcherAngleCalcStruct.gearRatio = 1 ;
	launcherAngleCalcStruct.diameter = units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() ;
	launcherAngleCalcStruct.countsPerInch = 0 ;
	launcherAngleCalcStruct.countsPerDegree = 2.352 ;

	launcherAngleDragonSparkMax = new DragonSparkMax ( 1,RobotElementNames::MOTOR_CONTROLLER_USAGE::NOTE_MANAGER_LAUNCHER_ANGLE,rev::CANSparkMax::MotorType::kBrushless,rev::SparkRelativeEncoder::Type::kHallSensor,rev::SparkLimitSwitch::Type::kNormallyOpen,rev::SparkLimitSwitch::Type::kNormallyOpen,launcherAngleCalcStruct );

	m_motorMap[launcherAngleDragonSparkMax->GetType()] = new BaseMechMotor ( m_ntName,
	    launcherAngleDragonSparkMax,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr );
	DistanceAngleCalcStruc PlacerCalcStruct;
	PlacerCalcStruct.countsPerRev = 0 ;
	PlacerCalcStruct.gearRatio = 1 ;
	PlacerCalcStruct.diameter = units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() ;
	PlacerCalcStruct.countsPerInch = 0 ;
	PlacerCalcStruct.countsPerDegree = 0 ;

	PlacerDragonSparkFlexMonitored = new DragonSparkFlexMonitored ( 7,RobotElementNames::MOTOR_CONTROLLER_USAGE::NOTE_MANAGER_PLACER,rev::CANSparkFlex::MotorType::kBrushless,rev::SparkRelativeEncoder::Type::kHallSensor,rev::SparkLimitSwitch::Type::kNormallyOpen,rev::SparkLimitSwitch::Type::kNormallyOpen,PlacerCalcStruct );

	m_motorMap[PlacerDragonSparkFlexMonitored->GetType()] = new BaseMechMotor ( m_ntName,
	    PlacerDragonSparkFlexMonitored,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr );
	DistanceAngleCalcStruc ElevatorCalcStruct;
	ElevatorCalcStruct.countsPerRev = 0 ;
	ElevatorCalcStruct.gearRatio = 1 ;
	ElevatorCalcStruct.diameter = units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() ;
	ElevatorCalcStruct.countsPerInch = 0.1168333 ;
	ElevatorCalcStruct.countsPerDegree = 0 ;

	ElevatorDragonSparkMax = new DragonSparkMax ( 3,RobotElementNames::MOTOR_CONTROLLER_USAGE::NOTE_MANAGER_ELEVATOR,rev::CANSparkMax::MotorType::kBrushless,rev::SparkRelativeEncoder::Type::kHallSensor,rev::SparkLimitSwitch::Type::kNormallyOpen,rev::SparkLimitSwitch::Type::kNormallyOpen,ElevatorCalcStruct );

	m_motorMap[ElevatorDragonSparkMax->GetType()] = new BaseMechMotor ( m_ntName,
	    ElevatorDragonSparkMax,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr,
	    BaseMechMotor::EndOfTravelSensorOption::NONE,
	    nullptr );
	if ( ( RobotConfigMgr::RobotIdentifier::COMP_BOT_302 == m_activeRobotId ) )
	{
		DistanceAngleCalcStruc launcherTopCalcStruct;
		launcherTopCalcStruct.countsPerRev = 1 ;
		launcherTopCalcStruct.gearRatio = 1 ;
		launcherTopCalcStruct.diameter = units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() ;
		launcherTopCalcStruct.countsPerInch = 0 ;
		launcherTopCalcStruct.countsPerDegree = 0 ;

		launcherTopDragonSparkFlex = new DragonSparkFlex ( 17,RobotElementNames::MOTOR_CONTROLLER_USAGE::NOTE_MANAGER_LAUNCHER_TOP,rev::CANSparkFlex::MotorType::kBrushless,rev::SparkRelativeEncoder::Type::kHallSensor,rev::SparkLimitSwitch::Type::kNormallyOpen,rev::SparkLimitSwitch::Type::kNormallyOpen,launcherTopCalcStruct );

		m_motorMap[launcherTopDragonSparkFlex->GetType()] = new BaseMechMotor ( m_ntName,
		    launcherTopDragonSparkFlex,
		    BaseMechMotor::EndOfTravelSensorOption::NONE,
		    nullptr,
		    BaseMechMotor::EndOfTravelSensorOption::NONE,
		    nullptr );
	}
	if ( ( RobotConfigMgr::RobotIdentifier::COMP_BOT_302 == m_activeRobotId ) )
	{
		DistanceAngleCalcStruc launcherBottomCalcStruct;
		launcherBottomCalcStruct.countsPerRev = 1 ;
		launcherBottomCalcStruct.gearRatio = 1 ;
		launcherBottomCalcStruct.diameter = units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() ;
		launcherBottomCalcStruct.countsPerInch = 0 ;
		launcherBottomCalcStruct.countsPerDegree = 0 ;

		launcherBottomDragonSparkFlex = new DragonSparkFlex ( 16,RobotElementNames::MOTOR_CONTROLLER_USAGE::NOTE_MANAGER_LAUNCHER_BOTTOM,rev::CANSparkFlex::MotorType::kBrushless,rev::SparkRelativeEncoder::Type::kHallSensor,rev::SparkLimitSwitch::Type::kNormallyOpen,rev::SparkLimitSwitch::Type::kNormallyOpen,launcherBottomCalcStruct );

		m_motorMap[launcherBottomDragonSparkFlex->GetType()] = new BaseMechMotor ( m_ntName,
		    launcherBottomDragonSparkFlex,
		    BaseMechMotor::EndOfTravelSensorOption::NONE,
		    nullptr,
		    BaseMechMotor::EndOfTravelSensorOption::NONE,
		    nullptr );
	}

	frontIntakeSensor = new DragonDigitalInput ( "frontIntakeSensor",RobotElementNames::DIGITAL_INPUT_USAGE::NOTE_MANAGER_FRONT_INTAKE_SENSOR,5,true,units::time::second_t ( 0 ) );
	backIntakeSensor = new DragonDigitalInput ( "backIntakeSensor",RobotElementNames::DIGITAL_INPUT_USAGE::NOTE_MANAGER_BACK_INTAKE_SENSOR,6,true,units::time::second_t ( 0 ) );
	feederSensor = new DragonDigitalInput ( "feederSensor",RobotElementNames::DIGITAL_INPUT_USAGE::NOTE_MANAGER_FEEDER_SENSOR,0,true,units::time::second_t ( 0 ) );
	launcherSensor = new DragonDigitalInput ( "launcherSensor",RobotElementNames::DIGITAL_INPUT_USAGE::NOTE_MANAGER_LAUNCHER_SENSOR,1,true,units::time::second_t ( 0 ) );
	placerInSensor = new DragonDigitalInput ( "placerInSensor",RobotElementNames::DIGITAL_INPUT_USAGE::NOTE_MANAGER_PLACER_IN_SENSOR,3,true,units::time::second_t ( 0 ) );
	placerMidSensor = new DragonDigitalInput ( "placerMidSensor",RobotElementNames::DIGITAL_INPUT_USAGE::NOTE_MANAGER_PLACER_MID_SENSOR,4,true,units::time::second_t ( 0 ) );
	placerOutSensor = new DragonDigitalInput ( "placerOutSensor",RobotElementNames::DIGITAL_INPUT_USAGE::NOTE_MANAGER_PLACER_OUT_SENSOR,2,true,units::time::second_t ( 0 ) );

	launcherAngleEncoder = new DragonCanCoder ( "launcherAngleEncoder",RobotElementNames::CANCODER_USAGE::NOTE_MANAGER_LAUNCHER_ANGLE_ENCODER,1,"rio",-0.3115234375,true );

	percentOutput = new ControlData (
	    ControlModes::CONTROL_TYPE::PERCENT_OUTPUT, // ControlModes::CONTROL_TYPE mode
	    ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
	    "percentOutput", // std::string indentifier
	    0, // double proportional
	    0, // double integral
	    0, // double derivative
	    0, // double feedforward
	    ControlData::FEEDFORWARD_TYPE::VOLTAGE, // FEEDFORWARD_TYPE feedforwadType
	    0, // double integralZone
	    0, // double maxAcceleration
	    0, // double cruiseVelocity
	    0, // double peakValue
	    0, // double nominalValue
	    false  // bool enableFOC
	);
	positionInch = new ControlData (
	    ControlModes::CONTROL_TYPE::POSITION_INCH, // ControlModes::CONTROL_TYPE mode
	    ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
	    "positionInch", // std::string indentifier
	    0.75, // double proportional
	    3E-05, // double integral
	    0, // double derivative
	    0, // double feedforward
	    ControlData::FEEDFORWARD_TYPE::VOLTAGE, // FEEDFORWARD_TYPE feedforwadType
	    0.5, // double integralZone
	    0, // double maxAcceleration
	    0, // double cruiseVelocity
	    0, // double peakValue
	    0, // double nominalValue
	    false  // bool enableFOC
	);
	velocityRPS = new ControlData (
	    ControlModes::CONTROL_TYPE::VELOCITY_RPS, // ControlModes::CONTROL_TYPE mode
	    ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
	    "velocityRPS", // std::string indentifier
	    0.0001, // double proportional
	    1E-07, // double integral
	    0, // double derivative
	    0.00014, // double feedforward
	    ControlData::FEEDFORWARD_TYPE::VOLTAGE, // FEEDFORWARD_TYPE feedforwadType
	    0, // double integralZone
	    0, // double maxAcceleration
	    0, // double cruiseVelocity
	    1, // double peakValue
	    0, // double nominalValue
	    false  // bool enableFOC
	);
	posDegreeAbs = new ControlData (
	    ControlModes::CONTROL_TYPE::POSITION_DEGREES, // ControlModes::CONTROL_TYPE mode
	    ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
	    "posDegreeAbs", // std::string indentifier
	    0.045, // double proportional
	    5.25E-06, // double integral
	    0, // double derivative
	    0, // double feedforward
	    ControlData::FEEDFORWARD_TYPE::VOLTAGE, // FEEDFORWARD_TYPE feedforwadType
	    0.5, // double integralZone
	    0, // double maxAcceleration
	    0, // double cruiseVelocity
	    0, // double peakValue
	    0, // double nominalValue
	    false  // bool enableFOC
	);
	positionInchUp = new ControlData (
	    ControlModes::CONTROL_TYPE::POSITION_INCH, // ControlModes::CONTROL_TYPE mode
	    ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
	    "positionInchUp", // std::string indentifier
	    1, // double proportional
	    3E-05, // double integral
	    0, // double derivative
	    0, // double feedforward
	    ControlData::FEEDFORWARD_TYPE::VOLTAGE, // FEEDFORWARD_TYPE feedforwadType
	    1, // double integralZone
	    0, // double maxAcceleration
	    0, // double cruiseVelocity
	    0, // double peakValue
	    0, // double nominalValue
	    false  // bool enableFOC
	);
	LauncherSafePositionControl = new ControlData (
	    ControlModes::CONTROL_TYPE::POSITION_DEGREES, // ControlModes::CONTROL_TYPE mode
	    ControlModes::CONTROL_RUN_LOCS::MOTOR_CONTROLLER, // ControlModes::CONTROL_RUN_LOCS server
	    "LauncherSafePositionControl", // std::string indentifier
	    0.025, // double proportional
	    3E-06, // double integral
	    0, // double derivative
	    0, // double feedforward
	    ControlData::FEEDFORWARD_TYPE::VOLTAGE, // FEEDFORWARD_TYPE feedforwadType
	    0.5, // double integralZone
	    0, // double maxAcceleration
	    0, // double cruiseVelocity
	    0, // double peakValue
	    0, // double nominalValue
	    false  // bool enableFOC
	);

	m_table = nt::NetworkTableInstance::GetDefault().GetTable ( m_ntName );
	m_tuningIsEnabledStr = "Enable Tuning for " + m_ntName; // since this string is used every loop, we do not want to create the string every time
	m_table.get()->PutBoolean ( m_tuningIsEnabledStr, m_tuning );
}

void noteManagerGen::InitializeCompBot302()
{
	frontIntakeDragonSparkMaxMonitored->SetRemoteSensor ( 0,
	        ctre::phoenix::motorcontrol::RemoteSensorSource::RemoteSensorSource_Off );
	frontIntakeDragonSparkMaxMonitored->Invert ( true );
	frontIntakeDragonSparkMaxMonitored->EnableBrakeMode ( true );
	frontIntakeDragonSparkMaxMonitored->SetSmartCurrentLimiting ( 25 );
	frontIntakeDragonSparkMaxMonitored->SetSecondaryCurrentLimiting ( 25, 0 );
	frontIntakeDragonSparkMaxMonitored->SetDiameter ( units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() );
	frontIntakeDragonSparkMaxMonitored->EnableDisableLimitSwitches ( false );
// frontIntake : Follower motor mode is not enabled
	frontIntakeDragonSparkMaxMonitored->SetVoltageRamping ( units::time::second_t ( units::time::second_t ( 0.25 ) ).to<double>(),
	        units::time::second_t ( units::time::second_t ( 0 ) ).to<double>() );
	frontIntakeDragonSparkMaxMonitored->SetSensorInverted ( false );

	frontIntakeDragonSparkMaxMonitored->ConfigureCurrentFiltering ( 7 );
	backIntakeDragonSparkMaxMonitored->SetRemoteSensor ( 0,
	        ctre::phoenix::motorcontrol::RemoteSensorSource::RemoteSensorSource_Off );
	backIntakeDragonSparkMaxMonitored->Invert ( true );
	backIntakeDragonSparkMaxMonitored->EnableBrakeMode ( true );
	backIntakeDragonSparkMaxMonitored->SetSmartCurrentLimiting ( 25 );
	backIntakeDragonSparkMaxMonitored->SetSecondaryCurrentLimiting ( 25, 0 );
	backIntakeDragonSparkMaxMonitored->SetDiameter ( units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() );
	backIntakeDragonSparkMaxMonitored->EnableDisableLimitSwitches ( false );
// backIntake : Follower motor mode is not enabled
	backIntakeDragonSparkMaxMonitored->SetVoltageRamping ( units::time::second_t ( units::time::second_t ( 0.25 ) ).to<double>(),
	        units::time::second_t ( units::time::second_t ( 0 ) ).to<double>() );
	backIntakeDragonSparkMaxMonitored->SetSensorInverted ( false );

	backIntakeDragonSparkMaxMonitored->ConfigureCurrentFiltering ( 7 );
	TransferDragonSparkMaxMonitored->SetRemoteSensor ( 0,
	        ctre::phoenix::motorcontrol::RemoteSensorSource::RemoteSensorSource_Off );
	TransferDragonSparkMaxMonitored->Invert ( true );
	TransferDragonSparkMaxMonitored->EnableBrakeMode ( false );
	TransferDragonSparkMaxMonitored->SetSmartCurrentLimiting ( 25 );
	TransferDragonSparkMaxMonitored->SetSecondaryCurrentLimiting ( 25, 0 );
	TransferDragonSparkMaxMonitored->SetDiameter ( units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() );
	TransferDragonSparkMaxMonitored->EnableDisableLimitSwitches ( false );
// Transfer : Follower motor mode is not enabled
	TransferDragonSparkMaxMonitored->SetVoltageRamping ( units::time::second_t ( units::time::second_t ( 0.25 ) ).to<double>(),
	        units::time::second_t ( units::time::second_t ( 0 ) ).to<double>() );
	TransferDragonSparkMaxMonitored->SetSensorInverted ( false );

	TransferDragonSparkMaxMonitored->ConfigureCurrentFiltering ( 7 );
	FeederDragonSparkFlexMonitored->SetRemoteSensor ( 0,
	        ctre::phoenix::motorcontrol::RemoteSensorSource::RemoteSensorSource_Off );
	FeederDragonSparkFlexMonitored->Invert ( false );
	FeederDragonSparkFlexMonitored->EnableBrakeMode ( true );
	FeederDragonSparkFlexMonitored->SetSmartCurrentLimiting ( 80 );
	FeederDragonSparkFlexMonitored->SetSecondaryCurrentLimiting ( 80, 0 );
	FeederDragonSparkFlexMonitored->SetDiameter ( units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() );
	FeederDragonSparkFlexMonitored->EnableDisableLimitSwitches ( false );
// Feeder : Follower motor mode is not enabled
	FeederDragonSparkFlexMonitored->SetVoltageRamping ( units::time::second_t ( units::time::second_t ( 0 ) ).to<double>(),
	        units::time::second_t ( units::time::second_t ( 0 ) ).to<double>() );
	FeederDragonSparkFlexMonitored->SetSensorInverted ( false );

	FeederDragonSparkFlexMonitored->ConfigureCurrentFiltering ( 7 );
	launcherAngleDragonSparkMax->SetRemoteSensor ( 0,
	        ctre::phoenix::motorcontrol::RemoteSensorSource::RemoteSensorSource_Off );
	launcherAngleDragonSparkMax->Invert ( true );
	launcherAngleDragonSparkMax->EnableBrakeMode ( true );
	launcherAngleDragonSparkMax->SetSmartCurrentLimiting ( 25 );
	launcherAngleDragonSparkMax->SetSecondaryCurrentLimiting ( 25, 0 );
	launcherAngleDragonSparkMax->SetDiameter ( units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() );
	launcherAngleDragonSparkMax->EnableDisableLimitSwitches ( true );
// launcherAngle : Follower motor mode is not enabled
	launcherAngleDragonSparkMax->SetVoltageRamping ( units::time::second_t ( units::time::second_t ( 0 ) ).to<double>(),
	        units::time::second_t ( units::time::second_t ( 0 ) ).to<double>() );
	launcherAngleDragonSparkMax->SetSensorInverted ( false );

	PlacerDragonSparkFlexMonitored->SetRemoteSensor ( 0,
	        ctre::phoenix::motorcontrol::RemoteSensorSource::RemoteSensorSource_Off );
	PlacerDragonSparkFlexMonitored->Invert ( false );
	PlacerDragonSparkFlexMonitored->EnableBrakeMode ( true );
	PlacerDragonSparkFlexMonitored->SetSmartCurrentLimiting ( 80 );
	PlacerDragonSparkFlexMonitored->SetSecondaryCurrentLimiting ( 80, 0 );
	PlacerDragonSparkFlexMonitored->SetDiameter ( units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() );
	PlacerDragonSparkFlexMonitored->EnableDisableLimitSwitches ( false );
// Placer : Follower motor mode is not enabled
	PlacerDragonSparkFlexMonitored->SetVoltageRamping ( units::time::second_t ( units::time::second_t ( 0.25 ) ).to<double>(),
	        units::time::second_t ( units::time::second_t ( 0 ) ).to<double>() );
	PlacerDragonSparkFlexMonitored->SetSensorInverted ( false );

	PlacerDragonSparkFlexMonitored->ConfigureCurrentFiltering ( 7 );
	ElevatorDragonSparkMax->SetRemoteSensor ( 0,
	        ctre::phoenix::motorcontrol::RemoteSensorSource::RemoteSensorSource_Off );
	ElevatorDragonSparkMax->Invert ( true );
	ElevatorDragonSparkMax->EnableBrakeMode ( true );
	ElevatorDragonSparkMax->SetSmartCurrentLimiting ( 25 );
	ElevatorDragonSparkMax->SetSecondaryCurrentLimiting ( 25, 0 );
	ElevatorDragonSparkMax->SetDiameter ( units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() );
	ElevatorDragonSparkMax->EnableDisableLimitSwitches ( true );
// Elevator : Follower motor mode is not enabled
	ElevatorDragonSparkMax->SetVoltageRamping ( units::time::second_t ( units::time::second_t ( 0.25 ) ).to<double>(),
	        units::time::second_t ( units::time::second_t ( 0 ) ).to<double>() );
	ElevatorDragonSparkMax->SetSensorInverted ( false );

	launcherTopDragonSparkFlex->SetRemoteSensor ( 0,
	        ctre::phoenix::motorcontrol::RemoteSensorSource::RemoteSensorSource_Off );
	launcherTopDragonSparkFlex->Invert ( false );
	launcherTopDragonSparkFlex->EnableBrakeMode ( false );
	launcherTopDragonSparkFlex->SetSmartCurrentLimiting ( 80 );
	launcherTopDragonSparkFlex->SetSecondaryCurrentLimiting ( 80, 0 );
	launcherTopDragonSparkFlex->SetDiameter ( units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() );
	launcherTopDragonSparkFlex->EnableDisableLimitSwitches ( false );
// launcherTop : Follower motor mode is not enabled
	launcherTopDragonSparkFlex->SetVoltageRamping ( units::time::second_t ( units::time::second_t ( 0 ) ).to<double>(),
	        units::time::second_t ( units::time::second_t ( 0 ) ).to<double>() );
	launcherTopDragonSparkFlex->SetSensorInverted ( false );

	launcherBottomDragonSparkFlex->SetRemoteSensor ( 0,
	        ctre::phoenix::motorcontrol::RemoteSensorSource::RemoteSensorSource_Off );
	launcherBottomDragonSparkFlex->Invert ( true );
	launcherBottomDragonSparkFlex->EnableBrakeMode ( false );
	launcherBottomDragonSparkFlex->SetSmartCurrentLimiting ( 80 );
	launcherBottomDragonSparkFlex->SetSecondaryCurrentLimiting ( 80, 0 );
	launcherBottomDragonSparkFlex->SetDiameter ( units::length::inch_t ( units::length::meter_t ( 1 ) ).to<double>() );
	launcherBottomDragonSparkFlex->EnableDisableLimitSwitches ( false );
// launcherBottom : Follower motor mode is not enabled
	launcherBottomDragonSparkFlex->SetVoltageRamping ( units::time::second_t ( units::time::second_t ( 0 ) ).to<double>(),
	        units::time::second_t ( units::time::second_t ( 0 ) ).to<double>() );
	launcherBottomDragonSparkFlex->SetSensorInverted ( false );

// frontIntakeSensor : Digital inputs do not have initialization needs
// backIntakeSensor : Digital inputs do not have initialization needs
// feederSensor : Digital inputs do not have initialization needs
// launcherSensor : Digital inputs do not have initialization needs
// placerInSensor : Digital inputs do not have initialization needs
// placerMidSensor : Digital inputs do not have initialization needs
// placerOutSensor : Digital inputs do not have initialization needs

// launcherAngleEncoder : CANcoder inputs do not have initialization needs

// percentOutput : ControlData does not have initialization needs
// positionInch : ControlData does not have initialization needs
// velocityRPS : ControlData does not have initialization needs
// posDegreeAbs : ControlData does not have initialization needs
// positionInchUp : ControlData does not have initialization needs
// LauncherSafePositionControl : ControlData does not have initialization needs

//todo create initialization for Off
//todo create initialization for Ready
//todo create initialization for feederIntake
//todo create initialization for Expel
//todo create initialization for placerIntake
//todo create initialization for holdFeeder
//todo create initialization for readyAutoLaunch
//todo create initialization for readyManualLaunch
//todo create initialization for Pass
//todo create initialization for autoLaunch
//todo create initialization for manualLaunch
//todo create initialization for readyOdometryLaunch
//todo create initialization for preparePlaceAmp
//todo create initialization for preparePlaceTrap
//todo create initialization for placeAmp
//todo create initialization for placeTrap
//todo create initialization for holdPlacer
//todo create initialization for readyPass
}

void noteManagerGen::SetCurrentState ( int state, bool run )
{
	StateMgr::SetCurrentState ( state, run );
}

/// @brief  Set the control constants (e.g. PIDF values).
/// @param [in] ControlData*                                   pid:  the control constants
/// @return void
void noteManagerGen::SetControlConstants ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, int slot, ControlData pid )
{
	auto motor = GetMotorMech ( identifier );
	if ( motor != nullptr )
	{
		motor->SetControlConstants ( slot, pid );
	}
}

/// @brief update the output to the mechanism using the current controller and target value(s)
/// @return void
void noteManagerGen::Update()
{
	for ( auto motor : m_motorMap )
	{
		motor.second->Update();
	}
}

void noteManagerGen::UpdateTarget ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, double percentOutput )
{
	auto motor = GetMotorMech ( identifier );
	if ( motor != nullptr )
	{
		motor->UpdateTarget ( percentOutput );
	}
}

void noteManagerGen::UpdateTarget ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, units::angle::degree_t angle )
{
	auto motor = GetMotorMech ( identifier );
	if ( motor != nullptr )
	{
		motor->UpdateTarget ( angle );
	}
}

void noteManagerGen::UpdateTarget ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, units::angular_velocity::revolutions_per_minute_t angVel )
{
	auto motor = GetMotorMech ( identifier );
	if ( motor != nullptr )
	{
		motor->UpdateTarget ( angVel );
	}
}
void noteManagerGen::UpdateTarget ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, units::length::inch_t position )
{
	auto motor = GetMotorMech ( identifier );
	if ( motor != nullptr )
	{
		motor->UpdateTarget ( position );
	}
}
void noteManagerGen::UpdateTarget ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier, units::velocity::feet_per_second_t velocity )
{
	auto motor = GetMotorMech ( identifier );
	if ( motor != nullptr )
	{
		motor->UpdateTarget ( velocity );
	}
}

bool noteManagerGen::IsAtMinPosition ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier ) const
{
	auto motor = GetMotorMech ( identifier );
	if ( motor != nullptr )
	{
		return motor->IsAtMinTravel();
	}
	return false;
}

bool noteManagerGen::IsAtMaxPosition ( RobotElementNames::MOTOR_CONTROLLER_USAGE identifier ) const
{
	auto motor = GetMotorMech ( identifier );
	if ( motor != nullptr )
	{
		return motor->IsAtMaxTravel();
	}
	return false;
}

BaseMechMotor *noteManagerGen::GetMotorMech ( RobotElementNames::MOTOR_CONTROLLER_USAGE usage ) const
{
	auto itr = m_motorMap.find ( usage );
	if ( itr != m_motorMap.end() )
	{
		return itr->second;
	}
	return nullptr;
}

std::vector<RobotElementNames::MOTOR_CONTROLLER_USAGE> noteManagerGen::GetMotorUsages() const
{
	std::vector<RobotElementNames::MOTOR_CONTROLLER_USAGE> output;
	for ( auto itr = m_motorMap.begin(); itr != m_motorMap.end(); ++itr )
	{
		output.emplace_back ( itr->first );
	}
	return output;
}

void noteManagerGen::UpdateTarget ( RobotElementNames::SOLENOID_USAGE identifier, bool extend )
{
	auto sol = GetSolenoidMech ( identifier );
	if ( sol != nullptr )
	{
		sol->ActivateSolenoid ( extend );
	}
}

bool noteManagerGen::IsAtMinPosition ( RobotElementNames::SOLENOID_USAGE identifier ) const
{
	auto sol = GetSolenoidMech ( identifier );
	if ( sol != nullptr )
	{
		return !sol->IsSolenoidActivated();
	}
	return false;
}

bool noteManagerGen::IsAtMaxPosition ( RobotElementNames::SOLENOID_USAGE identifier ) const
{
	auto sol = GetSolenoidMech ( identifier );
	if ( sol != nullptr )
	{
		return sol->IsSolenoidActivated();
	}
	return false;
}

BaseMechSolenoid *noteManagerGen::GetSolenoidMech ( RobotElementNames::SOLENOID_USAGE usage ) const
{
	auto itr = m_solenoidMap.find ( usage );
	if ( itr != m_solenoidMap.end() )
	{
		return itr->second;
	}
	return nullptr;
}

std::vector<RobotElementNames::SOLENOID_USAGE> noteManagerGen::GetSolenoidUsages() const
{
	std::vector<RobotElementNames::SOLENOID_USAGE> output;
	for ( auto itr = m_solenoidMap.begin(); itr != m_solenoidMap.end(); ++itr )
	{
		output.emplace_back ( itr->first );
	}
	return output;
}

BaseMechServo *noteManagerGen::GetServoMech ( RobotElementNames::SERVO_USAGE usage ) const
{
	auto itr = m_servoMap.find ( usage );
	if ( itr != m_servoMap.end() )
	{
		return itr->second;
	}
	return nullptr;
}

std::vector<RobotElementNames::SERVO_USAGE> noteManagerGen::GetServoUsages() const
{
	std::vector<RobotElementNames::SERVO_USAGE> output;
	for ( auto itr = m_servoMap.begin(); itr != m_servoMap.end(); ++itr )
	{
		output.emplace_back ( itr->first );
	}
	return output;
}

void noteManagerGen::Cyclic()
{
	CheckForTuningEnabled();
	if ( m_tuning )
	{
		ReadTuningParamsFromNT();
	}
}

void noteManagerGen::CheckForTuningEnabled()
{
	bool pastTuning = m_tuning;
	m_tuning = m_table.get()->GetBoolean ( m_tuningIsEnabledStr, false );
	if ( pastTuning != m_tuning && m_tuning == true )
	{
		PushTuningParamsToNT();
	}
}

void noteManagerGen::ReadTuningParamsFromNT()
{
	positionInch->SetIZone ( m_table.get()->GetNumber ( "positionInch_iZone", 0.5 ) );
	positionInch->SetF ( m_table.get()->GetNumber ( "positionInch_fGain", 0 ) );
	positionInch->SetP ( m_table.get()->GetNumber ( "positionInch_pGain", 0.75 ) );
	positionInch->SetI ( m_table.get()->GetNumber ( "positionInch_iGain", 3E-05 ) );
	positionInch->SetD ( m_table.get()->GetNumber ( "positionInch_dGain", 0 ) );
	velocityRPS->SetIZone ( m_table.get()->GetNumber ( "velocityRPS_iZone", 0 ) );
	velocityRPS->SetF ( m_table.get()->GetNumber ( "velocityRPS_fGain", 0.00014 ) );
	velocityRPS->SetP ( m_table.get()->GetNumber ( "velocityRPS_pGain", 0.0001 ) );
	velocityRPS->SetI ( m_table.get()->GetNumber ( "velocityRPS_iGain", 1E-07 ) );
	velocityRPS->SetD ( m_table.get()->GetNumber ( "velocityRPS_dGain", 0 ) );
	posDegreeAbs->SetIZone ( m_table.get()->GetNumber ( "posDegreeAbs_iZone", 0.5 ) );
	posDegreeAbs->SetF ( m_table.get()->GetNumber ( "posDegreeAbs_fGain", 0 ) );
	posDegreeAbs->SetP ( m_table.get()->GetNumber ( "posDegreeAbs_pGain", 0.045 ) );
	posDegreeAbs->SetI ( m_table.get()->GetNumber ( "posDegreeAbs_iGain", 5.25E-06 ) );
	posDegreeAbs->SetD ( m_table.get()->GetNumber ( "posDegreeAbs_dGain", 0 ) );
	positionInchUp->SetIZone ( m_table.get()->GetNumber ( "positionInchUp_iZone", 1 ) );
	positionInchUp->SetF ( m_table.get()->GetNumber ( "positionInchUp_fGain", 0 ) );
	positionInchUp->SetP ( m_table.get()->GetNumber ( "positionInchUp_pGain", 1 ) );
	positionInchUp->SetI ( m_table.get()->GetNumber ( "positionInchUp_iGain", 3E-05 ) );
	positionInchUp->SetD ( m_table.get()->GetNumber ( "positionInchUp_dGain", 0 ) );
	LauncherSafePositionControl->SetIZone ( m_table.get()->GetNumber ( "LauncherSafePositionControl_iZone", 0.5 ) );
	LauncherSafePositionControl->SetF ( m_table.get()->GetNumber ( "LauncherSafePositionControl_fGain", 0 ) );
	LauncherSafePositionControl->SetP ( m_table.get()->GetNumber ( "LauncherSafePositionControl_pGain", 0.025 ) );
	LauncherSafePositionControl->SetI ( m_table.get()->GetNumber ( "LauncherSafePositionControl_iGain", 3E-06 ) );
	LauncherSafePositionControl->SetD ( m_table.get()->GetNumber ( "LauncherSafePositionControl_dGain", 0 ) );

}

void noteManagerGen::PushTuningParamsToNT()
{
	m_table.get()->PutNumber ( "positionInch_iZone", positionInch->GetIZone() );
	m_table.get()->PutNumber ( "positionInch_fGain", positionInch->GetF() );
	m_table.get()->PutNumber ( "positionInch_pGain", positionInch->GetP() );
	m_table.get()->PutNumber ( "positionInch_iGain", positionInch->GetI() );
	m_table.get()->PutNumber ( "positionInch_dGain", positionInch->GetD() );
	m_table.get()->PutNumber ( "velocityRPS_iZone", velocityRPS->GetIZone() );
	m_table.get()->PutNumber ( "velocityRPS_fGain", velocityRPS->GetF() );
	m_table.get()->PutNumber ( "velocityRPS_pGain", velocityRPS->GetP() );
	m_table.get()->PutNumber ( "velocityRPS_iGain", velocityRPS->GetI() );
	m_table.get()->PutNumber ( "velocityRPS_dGain", velocityRPS->GetD() );
	m_table.get()->PutNumber ( "posDegreeAbs_iZone", posDegreeAbs->GetIZone() );
	m_table.get()->PutNumber ( "posDegreeAbs_fGain", posDegreeAbs->GetF() );
	m_table.get()->PutNumber ( "posDegreeAbs_pGain", posDegreeAbs->GetP() );
	m_table.get()->PutNumber ( "posDegreeAbs_iGain", posDegreeAbs->GetI() );
	m_table.get()->PutNumber ( "posDegreeAbs_dGain", posDegreeAbs->GetD() );
	m_table.get()->PutNumber ( "positionInchUp_iZone", positionInchUp->GetIZone() );
	m_table.get()->PutNumber ( "positionInchUp_fGain", positionInchUp->GetF() );
	m_table.get()->PutNumber ( "positionInchUp_pGain", positionInchUp->GetP() );
	m_table.get()->PutNumber ( "positionInchUp_iGain", positionInchUp->GetI() );
	m_table.get()->PutNumber ( "positionInchUp_dGain", positionInchUp->GetD() );
	m_table.get()->PutNumber ( "LauncherSafePositionControl_iZone", LauncherSafePositionControl->GetIZone() );
	m_table.get()->PutNumber ( "LauncherSafePositionControl_fGain", LauncherSafePositionControl->GetF() );
	m_table.get()->PutNumber ( "LauncherSafePositionControl_pGain", LauncherSafePositionControl->GetP() );
	m_table.get()->PutNumber ( "LauncherSafePositionControl_iGain", LauncherSafePositionControl->GetI() );
	m_table.get()->PutNumber ( "LauncherSafePositionControl_dGain", LauncherSafePositionControl->GetD() );

}